<!doctype html><html lang=en dir=ltr><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Handling Messages Asyncronously #  Blocking threads inside the actors creates contention therefore the handling of the messages must happen in a async fashion, including any DB writes and DB reads when starting the actor. For example, using interfaces such as Future[T]. However this may lead to concurrency within the actor itself removing the ilusion of a single thread. This means that messages must be stash until other operations complete."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Akka Actors"><meta property="og:description" content="Handling Messages Asyncronously #  Blocking threads inside the actors creates contention therefore the handling of the messages must happen in a async fashion, including any DB writes and DB reads when starting the actor. For example, using interfaces such as Future[T]. However this may lead to concurrency within the actor itself removing the ilusion of a single thread. This means that messages must be stash until other operations complete."><meta property="og:type" content="article"><meta property="og:url" content="https://bphenriques.github.io/knowledge-base/akka/akka_actors/"><title>Akka Actors | Bruno Henriques</title><link rel=manifest href=https://bphenriques.github.io/knowledge-base/manifest.json><link rel=icon href=https://bphenriques.github.io/knowledge-base/favicon.png type=image/x-icon><link rel=stylesheet href=https://bphenriques.github.io/knowledge-base/book.min.30d3414efaeb1d1ebd7cd338d441a193d2938a6c345cd477aa29b4113001564d.css integrity="sha256-MNNBTvrrHR69fNM41EGhk9KTimw0XNR3qim0ETABVk0="><script defer src=https://bphenriques.github.io/knowledge-base/en.search.min.ae90f4c5d76cf59dc9226361a87e4543e02ebe2e2435cf09129d657e5c07d8b4.js integrity="sha256-rpD0xdds9Z3JImNhqH5FQ+Auvi4kNc8JEp1lflwH2LQ="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=https://bphenriques.github.io/knowledge-base/><span>Bruno Henriques</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Akka</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_actors/ class=active>Akka Actors</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_cluster/>Akka Cluster</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_dispatcher/>Akka Dispatcher</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_router/>Akka Router</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_sharding/>Akka Sharding</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_streams/>Akka Streams</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_testing/>Akka Testing</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_overview/>Akka Overview</a></li></ul></li><li class=book-section-flat><span>Concurrency</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/concurrency/actor-model/>Actor Model</a></li><li><a href=https://bphenriques.github.io/knowledge-base/concurrency/amdah_s_law/>Amdah's Law</a></li><li><a href=https://bphenriques.github.io/knowledge-base/concurrency/gunther_s_universal_scalability_law/>Gunther's Universal Scalability Law</a></li></ul></li><li class=book-section-flat><span>Data Processing</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/data-processing/states-of-data/>States of Data</a></li></ul></li><li class=book-section-flat><span>Databases</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/databases/databases_overview/>Databases Overview</a></li><li><a href=https://bphenriques.github.io/knowledge-base/databases/databases_sharding-or-partitioning/>Sharding or Partitioning</a></li></ul></li><li class=book-section-flat><span>Documentation</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/documentation/readme/>Readme</a></li></ul></li><li class=book-section-flat><span>Editors</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/editors/emacs/>Emacs</a></li></ul></li><li class=book-section-flat><span>Learning</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/learning/coursera/>Coursera</a></li><li><a href=https://bphenriques.github.io/knowledge-base/learning/hands_on_scala_programming/>Hands-on Scala Programming</a></li><li><a href=https://bphenriques.github.io/knowledge-base/learning/technical_writing/>Technical Writing</a></li></ul></li><li class=book-section-flat><span>Messaging Systems</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/messaging-systems/messaging-systems-overview/>Messaging Systems Comparison</a></li></ul></li><li class=book-section-flat><span>Monitoring</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/monitoring/bug-management/>Bug Management</a></li></ul></li><li class=book-section-flat><span>Protocols</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/protocols/gossip_protocol/>Gossip Protocol</a></li><li><a href=https://bphenriques.github.io/knowledge-base/protocols/heartbeat/>Heartbeat</a></li></ul></li><li class=book-section-flat><span>Resources</span><ul></ul></li><li class=book-section-flat><span>Security</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/security/jwt/>JWT</a></li></ul></li><li class=book-section-flat><span>System Design</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/system-design/base_transaction/>BASE Transaction</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/command_query_responsibility_segregation/>Command Query Responsibility Segregation (CQRS)</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/command_sourcing/>Command Sourcing</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/>Consistency And Availability</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/>Domain Driven Design</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/event_sourcing_es_es/>Event Sourcing (ES)</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/>Message Driven Architecture</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/microservices/>Microservices</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/monolith/>Monolith</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/reactive_streams/>Reactive Streams</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/reactive_systems/>Reactive Systems</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/saga/>Saga</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture_soa/>Service Oriented Architecture (SOA)</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/system-design_sli-slo/>SLI/SLO</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/system-design_stateless/>Stateless</a></li></ul></li><li class=book-section-flat><span>Work</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/work/curriculum/>Curriculum</a></li><li><a href=https://bphenriques.github.io/knowledge-base/work/random-memories/>Random Memories</a></li><li><a href=https://bphenriques.github.io/knowledge-base/work/thinking_tools/>Thinking Tools</a></li><li><a href=https://bphenriques.github.io/knowledge-base/work/way-of-work/>Way of work</a></li></ul></li><li class=book-section-flat><span>Snippets</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/snippets/gpg/>GPG</a></li><li><a href=https://bphenriques.github.io/knowledge-base/snippets/jackson/>Jackson</a></li></ul></li><li class=book-section-flat><span>Blog Ideas</span><ul></ul></li><li class=book-section-flat><span>Uncategorized</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/nix/>Nix</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/web-stack-enties/>Stack Web Notes</a></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=https://bphenriques.github.io/knowledge-base/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Akka Actors</strong>
<label for=toc-control><img src=https://bphenriques.github.io/knowledge-base/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#handling-messages-asyncronously>Handling Messages Asyncronously</a></li><li><a href=#akka-actor-lifecycle>Akka Actor Lifecycle</a><ul><li><a href=#monitor>Monitor</a></li></ul></li><li><a href=#failure-handling>Failure Handling</a><ul><li><a href=#full-lifecycle>Full Lifecycle</a></li></ul></li><li><a href=#ask-vs-tell>Ask vs Tell</a></li></ul></nav></aside></header><article class=markdown><h2 id=handling-messages-asyncronously>Handling Messages Asyncronously
<a class=anchor href=#handling-messages-asyncronously>#</a></h2><p>Blocking threads inside the actors creates contention therefore the handling of the messages must happen in a async fashion, including any DB writes and DB reads when starting the actor. For example, using interfaces such as <code>Future[T]</code>. However this may lead to concurrency within the actor itself removing the ilusion of a single thread. This means that messages must be <em>stash</em> until other operations complete.</p><p>In essence the actor has 3 states:</p><ul><li>Loading - Load the state from the DB.</li><li>Running - Regular behavior.</li><li>Waiting.</li></ul><p>Question: If DB fails, then it is recommended to throw the exception leading to a restart of the Actor that in turn will re-read the state from the DB. So:</p><ul><li>It is explained that the stash is not lost, how?</li><li>What happens if there is a persistent issue in the DB? Will there be a loop?</li></ul><h2 id=akka-actor-lifecycle>Akka Actor Lifecycle
<a class=anchor href=#akka-actor-lifecycle>#</a></h2><p>Can be stopped by himself or by others.</p><p>Lifecycle (without faults):</p><pre><code class=language-nil data-lang=nil>hook:preStart() -&gt; started -[stop]-&gt; stopped -&gt; hook:postStop() -&gt; terminated
</code></pre><p>The actor is created assyncronously and available right away through the <code>ActorRef</code>.</p><p>Stopping an actor will:</p><ul><li>Finishes the processing the current message.</li><li>Suspends message processing.</li><li><strong>Stop its children</strong> - See <a href=https://bphenriques.github.io/knowledge-base/concurrency/actor-model/>Actor Model</a>.</li><li>Waits for their termination confirmations and then stops himself.</li></ul><p>How to stop: <code>PoisonPill</code> (<code>context.stop(self())</code>) and <code>actorRef ! Kill</code> messages (throw <code>ActorKilledException</code>). They are <strong>not</strong> appropriate to perform a cleanup before shutting down as the Actor does not &ldquo;see&rdquo; those messages (it is handled internally). It is best to use a dedicated message such as <code>StopMeGraciouslyMessage</code>.</p><h3 id=monitor>Monitor
<a class=anchor href=#monitor>#</a></h3><p><em>Dead Watch</em> allows monitoring another actor&rsquo;s termination (regular <code>Terminated</code> message in the <code>receive</code> block).</p><h2 id=failure-handling>Failure Handling
<a class=anchor href=#failure-handling>#</a></h2><p>Akka deals with failures at the level of the individual actor (bulkheading has it only affects that actor).</p><p>Does not throw the message back to the sender (b/c the sender does not know how to handle it). Instead the error is sent to a responsibile entity (e.g., &ldquo;Manager&rdquo;) that determines the required steps to recover.</p><p>When an actor fails, Akka provides two configurable strategies:</p><ul><li><em>OneForOneStrategy</em>: Only the faulty child is affected.</li><li><em>AllForOneStrategy</em>: All children are affected by one faulty child.</li></ul><p>Both are configured with a <code>type Decider = PartialFunction[Throwable, Directive]</code>. If not defined a directive, then the parent is consired faulty. Where <code>Directive</code>:</p><ul><li>Resume: Resume message processing. Use if the state remains valid.</li><li>Restart: Start a new actor in its place and resume, however all childs are stopped (by default unless <code>preRestart</code> hook is changed). It supports max number of retries and within a time limit.</li><li>Stop.</li><li>Escalate: Delegate the decision to the supervisor&rsquo;s parent.</li></ul><p>By default it is <em>OneForOneStrategy</em> with some directives that are too specific to group here and we can check the documentation. In short, by default, the actor will be restarted. In any case, message processing is suspended.</p><ul><li>All descendants of the actor are suspended.</li><li>The actor&rsquo;s parent handles the failure.</li></ul><p>Proper tuning leads to a self-healing system. Some exceptions are worth stopping the actor while others are worth recovering.</p><h3 id=full-lifecycle>Full Lifecycle
<a class=anchor href=#full-lifecycle>#</a></h3><figure><img src=_20201012_203109screenshot.png></figure><h2 id=ask-vs-tell>Ask vs Tell
<a class=anchor href=#ask-vs-tell>#</a></h2><p>Ask: <code>actorRef ? Message</code>
Tell: <code>actorRef ! Message</code></p><p>Use Ask when:</p><ul><li>Bridging non-actor code to actor-code (e.g., bridging with HTTP controllers ?).</li><li>We are expecting a response within a timeout. In this case we use <code>actorRef ? Message pipeTo self</code> which in turn will will handle the response, e.g., <code>val receive: Receive = { case MessageResponse => stuff }</code>.</li></ul><p>Use tell when:</p><ul><li>We do not care about the response.</li></ul><p>Neverthless, when using the ask operator, always ue pipeTo within the actor system to avoid breaking the single thread illusion.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div><a class="flex align-center" href=https://github.com/bphenriques/knowledge-base/edit/master/org/akka/akka_actors.org target=_blank rel=noopener><img src=https://bphenriques.github.io/knowledge-base/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#handling-messages-asyncronously>Handling Messages Asyncronously</a></li><li><a href=#akka-actor-lifecycle>Akka Actor Lifecycle</a><ul><li><a href=#monitor>Monitor</a></li></ul></li><li><a href=#failure-handling>Failure Handling</a><ul><li><a href=#full-lifecycle>Full Lifecycle</a></li></ul></li><li><a href=#ask-vs-tell>Ask vs Tell</a></li></ul></nav></div></aside></main></body></html>