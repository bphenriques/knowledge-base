<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Akka Streams #  Use cases: live-data, ETL systems, streaming.
 It is more efficient to consume asyncronously. Avoid flooding a slow consumer (backpressure).  Initiative to provide a standard for async stream processing with non-blocking backpressure.
Components of a Reactive Stream:
 Publisher: Publishes data to stream Subscriber: Consumes data from the stream. Processor: Acts as both a publisher and a subscriber, obeying the contract for each. Subscription: Connects a subscriber to a publisher to initiate a message flow."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Akka Streams"><meta property="og:description" content="Akka Streams #  Use cases: live-data, ETL systems, streaming.
 It is more efficient to consume asyncronously. Avoid flooding a slow consumer (backpressure).  Initiative to provide a standard for async stream processing with non-blocking backpressure.
Components of a Reactive Stream:
 Publisher: Publishes data to stream Subscriber: Consumes data from the stream. Processor: Acts as both a publisher and a subscriber, obeying the contract for each. Subscription: Connects a subscriber to a publisher to initiate a message flow."><meta property="og:type" content="article"><meta property="og:url" content="https://bphenriques.github.io/knowledge-base/akka/akka_streams/"><title>Akka Streams | Bruno Henriques</title><link rel=manifest href=https://bphenriques.github.io/knowledge-base/manifest.json><link rel=icon href=https://bphenriques.github.io/knowledge-base/favicon.png type=image/x-icon><link rel=stylesheet href=https://bphenriques.github.io/knowledge-base/book.min.c8d3866fece0f65580e9d9c5e7411c48781c968eb10c1b128e0521e3a9b441b2.css integrity="sha256-yNOGb+zg9lWA6dnF50EcSHgclo6xDBsSjgUh46m0QbI="><script defer src=https://bphenriques.github.io/knowledge-base/en.search.min.420847ddaa0fff238ad836eff9863852e708284d384e1fdedf41c41a4fb67918.js integrity="sha256-QghH3aoP/yOK2Dbv+YY4UucIKE04Th/e30HEGk+2eRg="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=https://bphenriques.github.io/knowledge-base/><span>Bruno Henriques</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Akka</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_cluster/>Akka Cluster</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_dispatcher/>Akka Dispatcher</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_router/>Akka Router</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_sharding/>Akka Sharding</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_streams/ class=active>Akka Streams</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_testing/>Akka Testing</a></li></ul></li><li class=book-section-flat><span>Concurrency</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/concurrency/actor-model/>Actor Model</a></li><li><a href=https://bphenriques.github.io/knowledge-base/concurrency/amdah_s_law/>Amdah's Law</a></li><li><a href=https://bphenriques.github.io/knowledge-base/concurrency/gunther_s_universal_scalability_law/>Gunther's Universal Scalability Law</a></li></ul></li><li class=book-section-flat><span>Data Processing</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/data-processing/states-of-data/>States of Data</a></li></ul></li><li class=book-section-flat><span>Databases</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/databases/databases_overview/>Databases Overview</a></li><li><a href=https://bphenriques.github.io/knowledge-base/databases/databases_sharding-or-partitioning/>Sharding or Partitioning</a></li></ul></li><li class=book-section-flat><span>Documentation</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/documentation/readme/>Readme</a></li></ul></li><li class=book-section-flat><span>Editors</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/editors/emacs/>Emacs</a></li></ul></li><li class=book-section-flat><span>Learning</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/learning/coursera/>Coursera</a></li><li><a href=https://bphenriques.github.io/knowledge-base/learning/hands_on_scala_programming/>Hands-on Scala Programming</a></li><li><a href=https://bphenriques.github.io/knowledge-base/learning/technical_writing/>Technical Writing</a></li></ul></li><li class=book-section-flat><span>Messaging Systems</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/messaging-systems/messaging-systems-overview/>Messaging Systems Comparison</a></li></ul></li><li class=book-section-flat><span>Monitoring</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/monitoring/bug-management/>Bug Management</a></li></ul></li><li class=book-section-flat><span>Protocols</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/protocols/gossip_protocol/>Gossip Protocol</a></li><li><a href=https://bphenriques.github.io/knowledge-base/protocols/heartbeat/>Heartbeat</a></li></ul></li><li class=book-section-flat><span>Resources</span><ul></ul></li><li class=book-section-flat><span>Security</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/security/jwt/>JWT</a></li></ul></li><li class=book-section-flat><span>System Design</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/system-design/command_query_responsibility_segregation/>Command Query Responsibility Segregation (CQRS)</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/command_sourcing/>Command Sourcing</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/>Consistency And Availability</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/>Domain Driven Design</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/event_sourcing/>Event Sourcing</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/>Message Driven Architecture</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/microservices/>Microservices</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/monolith/>Monolith</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/reactive_systems/>Reactive Systems</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture_soa/>Service Oriented Architecture (SOA)</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/system-design_sli-slo/>SLI/SLO</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/system-design_stateless/>Stateless</a></li></ul></li><li class=book-section-flat><span>Work</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/work/curriculum/>Curriculum</a></li><li><a href=https://bphenriques.github.io/knowledge-base/work/random-memories/>Random Memories</a></li><li><a href=https://bphenriques.github.io/knowledge-base/work/thinking_tools/>Thinking Tools</a></li><li><a href=https://bphenriques.github.io/knowledge-base/work/way-of-work/>Way of work</a></li></ul></li><li class=book-section-flat><span>Snippets</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/snippets/emacs/>Emacs</a></li><li><a href=https://bphenriques.github.io/knowledge-base/snippets/jackson/>Jackson</a></li></ul></li><li class=book-section-flat><span>Blog Ideas</span><ul></ul></li><li class=book-section-flat><span>Uncategorized</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/akka/>Akka</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/dotfiles/>dotfiles</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/gpg/>gpg</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/nix/>Nix</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/relevant-xkcds/>Relevant xkcds</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/web-stack-enties/>Stack Web Notes</a></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=https://bphenriques.github.io/knowledge-base/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Akka Streams</strong>
<label for=toc-control><img src=https://bphenriques.github.io/knowledge-base/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#akka-streams>Akka Streams</a><ul><li><a href=#how>How</a></li><li><a href=#backpressure>Backpressure</a></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=akka-streams>Akka Streams
<a class=anchor href=#akka-streams>#</a></h2><p>Use cases: live-data, ETL systems, streaming.</p><ul><li>It is more efficient to consume asyncronously.</li><li>Avoid flooding a slow consumer (backpressure).</li></ul><p>Initiative to provide a standard for async stream processing with non-blocking backpressure.</p><p>Components of a Reactive Stream:</p><ul><li>Publisher: Publishes data to stream</li><li>Subscriber: Consumes data from the stream.</li><li>Processor: Acts as both a publisher and a subscriber, obeying the contract for each.</li><li>Subscription: Connects a subscriber to a publisher to initiate a message flow.</li></ul><p>Streams of data are Messages that will be consumed by actors.</p><h3 id=how>How
<a class=anchor href=#how>#</a></h3><p>Data flows through a chain of processing stages. Each stage has zero or more inputs/outputs depending on the type. By default these stages run <strong>sync</strong> inside a single actor but can also be configured to run asyncronously in separate actors.</p><h4 id=linear-streams>Linear Streams
<a class=anchor href=#linear-streams>#</a></h4><figure><img src=_20201013_222125screenshot.png></figure><ul><li>Sources: the source of the data in the stream. E.g., CSV.</li><li>Sinks: the &ldquo;destination&rdquo; for the data. E.g., CSV file.</li><li>Flows: Transformations. E.g., Concatenate columns.</li><li>Runnable Graph: A stream where all the inputs and outputs are connected.</li></ul><p>Each stage can be run sync or async. In most cases the order is preserved.</p><p>Backpressure is propagated downstream stages to upstream.</p><ul><li><p>Source</p><p>Stage with single output: <code>Source[+Out, +Mat]</code>:</p><ul><li><code>Out</code>: The type of each element that is produced.</li><li><code>Mat</code>: Type of the materialized value. Usually <code>NotUsed</code>.</li></ul><p>Source only push data as long as there is demand. The source will have to deal with incoming data until demand resumes (how how largely demands on the use-case).</p><p>E.g., <code>empty</code>, <code>single</code>, <code>repeat</code> (repeat), <code>tick</code> (schedule), from iterables, cycle (same as iterable but repeats), stateful source ~unfold(initial)(fn), from actors, from files, tcp connections (!= data sent through it), java streams.</p></li></ul><ul><li><p>Sink</p><p>Stage with a single input: <code>Sink[-In, +Mat]</code>:</p><ul><li>In: The type of each element that is consumed.</li><li>Mat The type of each element that is produced. E.g., Future[Int].</li></ul><p>It creates backpressure by controlling <em>Demand</em>.</p><p>E.g., ignore, foreach (pure side effects as it does not return values), head/last, headOption/lastOption, seq (materialized all elements), stateful sinks such as fold and reduce, actorRef (no backpressure mechanism), actorRefAck (provides backpressure), FileIO.toPath, StreamConverts.fromJavaStream.</p><p>Note that if the stream is infinite, these sinks may never complete.</p></li></ul><ul><li><p>Flows</p><p>Single input and single output: <code>Flow[-In, +Out, +Mat]</code>.</p><p>Acts both as producer and consumer therefore it propagates demand to the producer as well propagating (and transforming) messages produced to downstream stages.</p><p>E.g., map, mapAsync(Parallelism) that still guarantees order, mayAsyncUnordered, mapConcat (similar to flatMap but not the same), grouped, sliding, fold, scan (emits each new computed result), filter, collect, limit by time using takeWithin(Duration), dropWithin(Duration), groupedWithin(Number, Duration), zip, flatMapConcat (similar mapConcat but operates on Sources rather than iterables), flatMapMerge (similar to flatMapContact but the substreams are consumed consumed therefore order is not guaranteed), buffer(size, strategy) (smooth incosistencies in the flow rate), for slow consumers/producers we have expand (extrapolate for slow producers), batch (for slow consumer) and conflate (create summary of the elements when the producer is faster), log.</p><p>Some of these operations are directly accessible from <code>Source</code> and does not require additional typing.</p></li></ul><ul><li><p>Runnable Graphs</p><p>Connects source, flows, sinks so that data can start flowing.</p><p>E.g.,:</p><ul><li>to: materializes the value from left to right. - Returns Cancellable.</li><li>toMat: Transform/combine materialized values: <code>source.viaMat(flow)(Keep.right).to(sink).run()</code> - Returns NotUsed.</li><li>viaMat: Similar but operates on a flow as opposed to sink - Returns Future[Done].</li></ul></li></ul><ul><li><p>Fault Tolerancy.</p><p>Default strategy is to stop processing the stream and can be overriden within the <code>ActorMaterializer</code> by passing a decider that given an exception it either decides:</p><ul><li>Stop: terminate with an error.</li><li>Resume: Drop the failing element.</li><li>Restart: The element is dropped and the stream continues after restarting the stage. Any state acumulated by that stage will be cleared.</li></ul><p>Each stage can be fine-tuned to choose a dispatchet, bufferSize, log levels and supervision.</p><p>Sometimes errors are recoverable which is a <code>Throwable -> T</code>.</p></li></ul><ul><li><p>Graphs</p><p>Introduces Junctions which take multiple inputs and multiple outputs. Basic ones are:</p><ul><li>Fan in: N inputs + 1 output. E.g., Merge (random selects from the inputs), MergePreferred (give one input higher priority), ZipWith (arity N), Zip (arity 2), Concat.</li><li>Fan out: 1 input + N outputs. E.g., Broadcast, Balance (to just one of the outputs), UnzipWithin to for example split a tuple to send to the outputs, UnZip splits a tuple[A, B] onto 2 streams A and B.</li></ul><figure><img src=_20201014_220602screenshot.png></figure></li></ul><ul><li><p>Fusion</p><p>Until now all of this runs syncronously as Akka &ldquo;fuses&rdquo; all stages onto a single syncronous one.</p><figure><img src=_20201014_224503screenshot.png></figure><p>When fused on, buffers are not present in each stage. When turned-off each stage has a dedicated buffer once we start processing stages asyncronously.</p><p>We can disable fusing for everything however we can be more selective: <code>Source(1 to 10).async.runForEach(println)</code>. This creates overhead of:</p><ul><li>Actors.</li><li>Mailboxes.</li><li>Buffers.</li></ul><p>It is not a magic bullet. Performance gain/loss depends on the use-case.</p><p>Fusion optimization principles is: &ldquo;insert an async boundary to bisect the stream into two subsections of roughly equal processing time.&rdquo;. In other words, check at the current pipeline where the stages can be split so that they can be performed in paralell and joined almost at the same time. This implies looking at Grafana, analyse each stage and compare with the stream graph we have.</p><p>Lesson: Do not multitask on your computer while you are doing benchmarks :P This affected the exercises throughput by <em>a lot</em>.</p></li></ul><h4 id=graphs>Graphs
<a class=anchor href=#graphs>#</a></h4><figure><img src=_20201013_222507screenshot.png></figure><p>Linear streams are most of the times sufficient. However, there are some cases where there are multiple inputs and outputs. Leading to additional components:</p><ul><li>Junctions: Branch points in the stream (e.g., fan-in, fan-out).</li></ul><p>All the introduced components are immutable and can be reused in different scenarios as they solely contain instructions to do <em>something</em> with the data.</p><h4 id=example>Example
<a class=anchor href=#example>#</a></h4><p>Simple stream:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#a6e22e>Source</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span> to <span style=color:#ae81ff>10</span><span style=color:#f92672>)</span>                  <span style=color:#75715e>// source
</span><span style=color:#75715e></span>  <span style=color:#f92672>.</span>via<span style=color:#f92672>(</span><span style=color:#a6e22e>Flow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Int</span><span style=color:#f92672>].</span>map<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>))</span>     <span style=color:#75715e>// stage
</span><span style=color:#75715e></span>  <span style=color:#f92672>.</span>to<span style=color:#f92672>(</span><span style=color:#a6e22e>Sink</span><span style=color:#f92672>.</span>foreach<span style=color:#f92672>(</span>println<span style=color:#f92672>))</span>     <span style=color:#75715e>// sink
</span><span style=color:#75715e></span>  <span style=color:#f92672>.</span>run                           <span style=color:#75715e>// materialize the graph
</span></code></pre></div><h3 id=backpressure>Backpressure
<a class=anchor href=#backpressure>#</a></h3><figure><img src=_20201013_221335screenshot.png></figure><ul><li><p>pull/push mechanism.</p><p>Subscribers signal demand that is sent upstream via subscription. Publishers then push data (if available), this way publisher does not send more information than that it was demanded.</p></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div><a class="flex align-center" href=https://github.com/bphenriques/knowledge-base/edit/master/org/akka/akka_streams.org target=_blank rel=noopener><img src=https://bphenriques.github.io/knowledge-base/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#akka-streams>Akka Streams</a><ul><li><a href=#how>How</a></li><li><a href=#backpressure>Backpressure</a></li></ul></li></ul></nav></aside></main></body></html>