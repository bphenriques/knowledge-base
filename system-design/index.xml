<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>System Design on Bruno Henriques</title><link>https://bphenriques.github.io/knowledge-base/system-design/</link><description>Recent content in System Design on Bruno Henriques</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://bphenriques.github.io/knowledge-base/system-design/index.xml" rel="self" type="application/rss+xml"/><item><title>Command Query Responsibility Segregation (CQRS)</title><link>https://bphenriques.github.io/knowledge-base/system-design/command_query_responsibility_segregation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/command_query_responsibility_segregation/</guid><description>Eventually consistent by design which always present but now is explicit about it.
Some Aggregate Roots are a better fit for write models but do not fit other read models. Requirements for both models are different.
Command Query Responsibility Segregation (CQRS) aims to separate read models from write models. This is specially problematic when using Event Sourcing. Note that Event Sourcing is not a requirement for CQRS but are often combined.</description></item><item><title>Command Sourcing</title><link>https://bphenriques.github.io/knowledge-base/system-design/command_sourcing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/command_sourcing/</guid><description>Command Sourcing # Similar to Event Sourcing but persists commands as opposed to events so:
Issue command
Persist command
Run asyncronous the command
They should be idempotent as they run multiple times (e.g., failures).
Must be validated so that they do not become stuck in the queue forever.
Bad: The sender might not be notified if the command fails due to the decouple nature.</description></item><item><title>Consistency And Availability</title><link>https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/</guid><description>Scalability # It can meets increases in demand while remaining responsive.
This is different from performance. Performance optimizes response time (latency) while scalability optimizes ability to handle load. Requests per second actually measures both but we do not know which aspect was improved.
Note Scalability is not the number of requests qwe can handle a in a given period of time (req/sec) but he number of requests itself (load).</description></item><item><title>CQRS/ES</title><link>https://bphenriques.github.io/knowledge-base/system-design/cqrs_es/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/cqrs_es/</guid><description>CQRS/ES stands for Command Query Responsibility Segregation and Event Sourcing.
Use Cases:
Auditing (e.g., banking, accounting) High Scalability High Resiliency There are trade-offs, what are they?
CQRS # State Based Persistence. Every time an update is applied to the database it obliterates previous state.
Can&amp;rsquo;t fix bad state due to previous error. Can&amp;rsquo;t retroactively apply new domain insights (because we do not have the previous states). This solely tells where we are but not how we got there: must be allied with Event Sourcing.</description></item><item><title>Domain Driven Design</title><link>https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/</guid><description>See raw in Lightbend Academy
Useful for modelling use-cases before attempting to implement it whether in Software or mere Diagrams.
Subject-Verb-Object notation # Allows having a consistent way to phrase activies our events in the domain.
Example: Host checks current reservation.
Subject: Host Verb: Checks Object: Reservation Note that &amp;ldquo;current&amp;rdquo; can be seen as a modifier.
Sometimes there may be multiple objects. E.g., &amp;ldquo;Bartender collects Payment for a Drink Order&amp;rdquo;:</description></item><item><title>Event Sourcing</title><link>https://bphenriques.github.io/knowledge-base/system-design/event_sourcing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/event_sourcing/</guid><description>Event Sourcing (ES) # In addition to persisting state, one persists audit logs. This captures the history. It is better to have this in a database as it provides transactionality.
Wary when persisting in the database and in-memory:
Two potential source of truth if they disagree. Both must be updated in transactionality. A bug in the code may lead to both of them becoming out-of-sync. Q: What happens if the audit logs gets out-of-sync with the state?</description></item><item><title>Message Driven Architecture</title><link>https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/</guid><description>Asyncronous and non-blocking. The sender does not actively wait for a response.
Advantages:
Resources are freed immediatly. Reduced contention Messages can be queued for deleivery in case the receiver&amp;rsquo;s is offline. Provides a higher level of reliability. Disavantages:
Make transactions more difficult. How to manage long running transactions that span multiple microservices. Holding transactions open for long periods result in slow, brittle systems. The role of syncronous messags:</description></item><item><title>Microservices</title><link>https://bphenriques.github.io/knowledge-base/system-design/microservices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/microservices/</guid><description>Subset of Service Oriented Architecture where each service is deployed separately:
Microservices can be physically separated and independently deployed. Each have its own data store. Independent and self governing. Communication is syncronous or asyncronous (e.g., through message brokers). Loose coupling between components (more or less by experience but that is design flaw likely :thinking:). Shorter development and release cycles. Each scale independently (either through physical or virtual machines). Advantages # Deployed/Scaled as needed.</description></item><item><title>Monolith</title><link>https://bphenriques.github.io/knowledge-base/system-design/monolith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/monolith/</guid><description>Some notes taken during the lightbend course on Reactive Microservices. Some of these ideas are familiar as they are intuitive.
Deployed as a single unit. No Clear Isolation. Complex Depedencies -&amp;gt; Hard to understand and modify. Communication using syncronous calls. Hmmm, I disagree and I think that it depends.. E.g., Spring allows services call another with asyncronous methods within the same monolith. I guess that it depends on the spectrum of monolith we are talking about.</description></item><item><title>Reactive Systems</title><link>https://bphenriques.github.io/knowledge-base/system-design/reactive_systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/reactive_systems/</guid><description>Goal # Provide an experience that is responsive under all conditions.
This requires:
Ability to scale from 10 users to million of users. Consume solely the resources required to support the current work-load. Reactor Principles # Responsive # Always respond in a timely manner.
Resiliency # Isolate failures on single components - Similar to how a boat is designed.
Elastic # Keep responsive specially when the system load changes which provides a more efficient usage of resources.</description></item><item><title>Service Oriented Architecture</title><link>https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture/</guid><description>As opposed to Monolith, services do not share a database and all access must be done through a API exposed by the service. They may be in the same process (Monolith) or may be separated (Microservices). This reduces coupling.
E.g.:
Orders -&amp;gt; RDBMS Customers -&amp;gt; No SQL Reservations -&amp;gt; Web Service Menu -&amp;gt; RDBMS</description></item><item><title>Stateless</title><link>https://bphenriques.github.io/knowledge-base/system-design/system-design_stateless/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/system-design_stateless/</guid><description>Requests are self-contained and have all the information required to be completed. Requests can be processed on any instance of the application. Some &amp;ldquo;Stateless&amp;rdquo; systems are not trully stateless as the state is contained in a database:
Required to have strong consistency (the single source of truth). However this means that the database may become the bottleneck. The database also represents the single point of failure which may lead to an unresponsive systems.</description></item><item><title>System Design Articles</title><link>https://bphenriques.github.io/knowledge-base/system-design/articles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/articles/</guid><description> http://boringtechnology.club/</description></item></channel></rss>