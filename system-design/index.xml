<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>System Design on Bruno Henriques</title><link>https://bphenriques.github.io/knowledge-base/system-design/</link><description>Recent content in System Design on Bruno Henriques</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://bphenriques.github.io/knowledge-base/system-design/index.xml" rel="self" type="application/rss+xml"/><item><title>Command Query Responsibility Segregation (CQRS)</title><link>https://bphenriques.github.io/knowledge-base/system-design/command_query_responsibility_segregation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/command_query_responsibility_segregation/</guid><description>Use Cases # Auditing (e.g., banking, accounting) High Scalability High Resiliency Some Aggregate Roots are a better fit for write models but do not fit other read models. Requirements for both models are different.
What # Command Query Responsibility Segregation (CQRS) aims to separate read models from write models. This is specially problematic when using Event Sourcing. Note that Event Sourcing is not a requirement for CQRS but are often combined.</description></item><item><title>Command Sourcing</title><link>https://bphenriques.github.io/knowledge-base/system-design/command_sourcing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/command_sourcing/</guid><description>Command Sourcing # Similar to Event Sourcing but persists commands as opposed to events so:
Issue command
Persist command
Run asyncronous the command
They should be idempotent as they run multiple times (e.g., failures).
Must be validated so that they do not become stuck in the queue forever.
Bad: The sender might not be notified if the command fails due to the decouple nature.</description></item><item><title>Consistency And Availability</title><link>https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/</guid><description>Scalability # It can meets increases in demand while remaining responsive.
This is different from performance. Performance optimizes response time (latency) while scalability optimizes ability to handle load. Requests per second actually measures both but we do not know which aspect was improved.
Note Scalability is not the number of requests qwe can handle a in a given period of time (req/sec) but he number of requests itself (load).</description></item><item><title>Domain Driven Design</title><link>https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/</guid><description>Goal # Evolving Shared Model understood by domain experts and by who implements it. Being a model, it means that it can be implemented in different ways, from diagrams to software. Regardless of how it is implemented, it must reflect the model.
Useful for modelling use-cases before attempting to implement it whether in Software or mere Diagrams.
Ubiquitous Languague # Common language that enables communication between the domain experts and the developers.</description></item><item><title>Event Sourcing</title><link>https://bphenriques.github.io/knowledge-base/system-design/event_sourcing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/event_sourcing/</guid><description>Event Sourcing (ES) # In addition to persisting state, one persists audit logs. This captures the history. It is better to have this in a database as it provides transactionality.
Wary when persisting in the database and in-memory:
Two potential source of truth if they disagree. Both must be updated in transactionality. A bug in the code may lead to both of them becoming out-of-sync. Q: What happens if the audit logs gets out-of-sync with the state?</description></item><item><title>Message Driven Architecture</title><link>https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/</guid><description>Asyncronous and non-blocking. The sender does not actively wait for a response.
Advantages:
Resources are freed immediatly. Reduced contention Messages can be queued for deleivery in case the receiver&amp;rsquo;s is offline. Provides a higher level of reliability. Disavantages:
Make transactions more difficult. How to manage long running transactions that span multiple microservices. Holding transactions open for long periods result in slow, brittle systems. The role of syncronous messags:</description></item><item><title>Microservices</title><link>https://bphenriques.github.io/knowledge-base/system-design/microservices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/microservices/</guid><description>Subset of Service Oriented Architecture (SOA) where each service is deployed separately:
Microservices can be physically separated and independently deployed. Each have its own data store. Independent and self governing. Communication is syncronous or asyncronous (e.g., through message brokers). Loose coupling between components (more or less by experience but that is design flaw likely :thinking:). Shorter development and release cycles. Each scale independently (either through physical or virtual machines). Advantages # Deployed/Scaled as needed.</description></item><item><title>Monolith</title><link>https://bphenriques.github.io/knowledge-base/system-design/monolith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/monolith/</guid><description>Charateristics # Deployed as a single unit. No Clear Isolation. Complex Depedencies which in turn makes it hard to understand and modify. Big Bang Style Releases Long Cycle Times Careful releases Scalation is done with multiple copies and uses the database as consistency between them. Advantages: # Easy Cross Module Refactor Easier to maitain consistency Single Deploy Process Single thing to monitor Simple Scalability Model Disavantages: # Limited by the maximum size of a single phyisical machine.</description></item><item><title>Reactive Systems</title><link>https://bphenriques.github.io/knowledge-base/system-design/reactive_systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/reactive_systems/</guid><description>Goal # Provide an experience that is responsive under all conditions. Note that reactive programming is not the same as reactive systems.
This requires:
Ability to scale from 10 users to million of users. Consume solely the resources required to support the current work-load. Reactive Principles # Systems that apply the following principles are considered reactive systems (see more here).
Responsive # Always respond in a timely manner.</description></item><item><title>Service Oriented Architecture (SOA)</title><link>https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture_soa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture_soa/</guid><description>TODO very incomplete # As opposed to Monolith, services do not share a database and all access must be done through a API exposed by the service. They may be in the same process (Monolith) or may be separated (Microservices). This reduces coupling.</description></item><item><title>SLI/SLO</title><link>https://bphenriques.github.io/knowledge-base/system-design/system-design_sli-slo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/system-design_sli-slo/</guid><description>Service Level Indicator (SLI): Performance indicator measured as a ratio of two numbers. Service Level Objective (SLO): Defines a target SLI as measurment of the systems&amp;rsquo;s reliability. Service Level Agreement (SLA): Business contract regarding the expected SLO. It is far productive measuring them as use-histories as it defines the critical paths.</description></item><item><title>Stateless</title><link>https://bphenriques.github.io/knowledge-base/system-design/system-design_stateless/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/system-design_stateless/</guid><description>Requests are self-contained and have all the information required to be completed. Requests can be processed on any instance of the application. Some &amp;ldquo;Stateless&amp;rdquo; systems are not trully stateless as the state is contained in a database:
Required to have strong consistency (the single source of truth). However this means that the database may become the bottleneck. The database also represents the single point of failure which may lead to an unresponsive systems.</description></item><item><title>System Design Articles</title><link>https://bphenriques.github.io/knowledge-base/system-design/articles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/articles/</guid><description> http://boringtechnology.club/</description></item></channel></rss>