<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Akka Cluster #  Scenario: Make actors communicate across the network.
Allows actors to communicate across the network, greatly simplifying the process. Each node represents an actor system and they all share the same name.
Akka Cluster Aware Routers #  Scenario: High workload.
Scalling vertically has limits. Introducing Akka Cluster Aware Routers, that allows scalling the system horizontally. I.e., large tasks are broken on smaller tasks that are routed to an especific node of our cluster."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Akka Cluster"><meta property="og:description" content="Akka Cluster #  Scenario: Make actors communicate across the network.
Allows actors to communicate across the network, greatly simplifying the process. Each node represents an actor system and they all share the same name.
Akka Cluster Aware Routers #  Scenario: High workload.
Scalling vertically has limits. Introducing Akka Cluster Aware Routers, that allows scalling the system horizontally. I.e., large tasks are broken on smaller tasks that are routed to an especific node of our cluster."><meta property="og:type" content="article"><meta property="og:url" content="https://bphenriques.github.io/knowledge-base/notes/akka_cluster/"><meta property="article:section" content="notes"><title>Akka Cluster | Bruno Henriques's Digital Garden ðŸŒ±</title><link rel=icon href=/knowledge-base/favicon.png type=image/x-icon><link rel=stylesheet href=/knowledge-base/scss/explorer.min.81227fe14d47ca25b022b9b15feec75f9eb2a749e8453568ef9edad255a06da9.css integrity="sha256-gSJ/4U1HyiWwIrmxX+7HX56yp0noRTVo757a0lWgbak=" crossorigin=anonymous><script defer src=/knowledge-base/js/vendor/flexsearch.bundle.js></script><script defer src=/knowledge-base/js/search.min.f194e85d309adae058282f0ea2266359fe8ec0a80095467ac13c18625cd3a197.js integrity="sha256-8ZToXTCa2uBYKC8OoiZjWf6OwKgAlUZ6wTwYYlzToZc=" crossorigin=anonymous></script><script defer src=/knowledge-base/js/clipboard.min.14b9ccf5803971502776b44d95026b084e5fa02a544dc0e4cd86a7db76f691b2.js integrity="sha256-FLnM9YA5cVAndrRNlQJrCE5foCpUTcDkzYan23b2kbI=" crossorigin=anonymous></script></head><body><input type=checkbox class="hidden toggle" id=site-menu-control>
<input type=checkbox class="hidden toggle" id=content-menu-control><main class="container flex"><aside class=site-menu><div class=site-menu-content><nav><h2 class=brand><a class="flex align-center" href=/knowledge-base/><span>Bruno Henriques</span></a></h2><div class=search><input type=text id=search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="search-spinner hidden"></div><ul id=search-results class=item-preview-list></ul></div><a class=site-menu-shortcut-link href=/knowledge-base/notes>Recent Notes</a><p class=site-menu-tags-title><b>Tags</b></p><ul><li><a class=list-tag-item href=/knowledge-base/tags/akka><div class=tag-dot style=background-color:#ffecb3></div>Akka</a></li><li><a class=list-tag-item href=/knowledge-base/tags/aws><div class=tag-dot style=background-color:#f5f5f5></div>Aws</a></li><li><a class=list-tag-item href=/knowledge-base/tags/concurrency><div class=tag-dot style=background-color:#f5f5f5></div>Concurrency</a></li><li><a class=list-tag-item href=/knowledge-base/tags/data><div class=tag-dot style=background-color:#ffe0b2></div>Data</a></li><li><a class=list-tag-item href=/knowledge-base/tags/data-structures><div class=tag-dot style=background-color:#ffcdd2></div>Data structures</a></li><li><a class=list-tag-item href=/knowledge-base/tags/databases><div class=tag-dot style=background-color:#f1f8e9></div>Databases</a></li><li><a class=list-tag-item href=/knowledge-base/tags/dispatcher><div class=tag-dot style=background-color:#c8e6c9></div>Dispatcher</a></li><li><a class=list-tag-item href=/knowledge-base/tags/docker><div class=tag-dot style=background-color:#b9f6ca></div>Docker</a></li><li><a class=list-tag-item href=/knowledge-base/tags/docker-compose><div class=tag-dot style=background-color:#ffe0b2></div>Docker compose</a></li><li><a class=list-tag-item href=/knowledge-base/tags/dotfiles><div class=tag-dot style=background-color:#ab9df2></div>Dotfiles</a></li><li><a class=list-tag-item href=/knowledge-base/tags/editors><div class=tag-dot style=background-color:#ffb74d></div>Editors</a></li><li><a class=list-tag-item href=/knowledge-base/tags/flakes><div class=tag-dot style=background-color:#c8e6c9></div>Flakes</a></li><li><a class=list-tag-item href=/knowledge-base/tags/functional-programming><div class=tag-dot style=background-color:#ffebee></div>Functional programming</a></li><li><a class=list-tag-item href=/knowledge-base/tags/jq><div class=tag-dot style=background-color:#e1f5fe></div>Jq</a></li><li><a class=list-tag-item href=/knowledge-base/tags/json><div class=tag-dot style=background-color:#ffebee></div>JSON</a></li><li><a class=list-tag-item href=/knowledge-base/tags/jvm><div class=tag-dot style=background-color:#90caf9></div>Jvm</a></li><li><a class=list-tag-item href=/knowledge-base/tags/kotlin><div class=tag-dot style=background-color:#ffe57f></div>Kotlin</a></li><li><a class=list-tag-item href=/knowledge-base/tags/lightbend><div class=tag-dot style=background-color:#f0f4c3></div>Lightbend</a></li><li><a class=list-tag-item href=/knowledge-base/tags/monitoring><div class=tag-dot style=background-color:#e3f2fd></div>Monitoring</a></li><li><a class=list-tag-item href=/knowledge-base/tags/nix><div class=tag-dot style=background-color:#c5e1a5></div>Nix</a></li><li><a class=list-tag-item href=/knowledge-base/tags/note><div class=tag-dot style=background-color:#bbdefb></div>Note</a></li><li><a class=list-tag-item href=/knowledge-base/tags/postgres><div class=tag-dot style=background-color:#b2dfdb></div>Postgres</a></li><li><a class=list-tag-item href=/knowledge-base/tags/protocols><div class=tag-dot style=background-color:#ab9df2></div>Protocols</a></li><li><a class=list-tag-item href=/knowledge-base/tags/psql><div class=tag-dot style=background-color:#e0f2f1></div>Psql</a></li><li><a class=list-tag-item href=/knowledge-base/tags/queue><div class=tag-dot style=background-color:#ffebee></div>Queue</a></li><li><a class=list-tag-item href=/knowledge-base/tags/reference><div class=tag-dot style=background-color:#00bfa5></div>Reference</a></li><li><a class=list-tag-item href=/knowledge-base/tags/router><div class=tag-dot style=background-color:#c8e6c9></div>Router</a></li><li><a class=list-tag-item href=/knowledge-base/tags/scala><div class=tag-dot style=background-color:#ffd180></div>Scala</a></li><li><a class=list-tag-item href=/knowledge-base/tags/security><div class=tag-dot style=background-color:#b3e5fc></div>Security</a></li><li><a class=list-tag-item href=/knowledge-base/tags/signing><div class=tag-dot style=background-color:#ffd866></div>Signing</a></li><li><a class=list-tag-item href=/knowledge-base/tags/snippets><div class=tag-dot style=background-color:#e1f5fe></div>Snippets</a></li><li><a class=list-tag-item href=/knowledge-base/tags/stream><div class=tag-dot style=background-color:#d1c4e9></div>Stream</a></li><li><a class=list-tag-item href=/knowledge-base/tags/system-design><div class=tag-dot style=background-color:#ffebee></div>System design</a></li><li><a class=list-tag-item href=/knowledge-base/tags/testing><div class=tag-dot style=background-color:#e0e0e0></div>Testing</a></li><li><a class=list-tag-item href=/knowledge-base/tags/work><div class=tag-dot style=background-color:#f5f5f5></div>Work</a></li><li><a class=list-tag-item href=/knowledge-base/tags/zettelkasten><div class=tag-dot style=background-color:#e3f2fd></div>Zettelkasten</a></li></ul></nav></div></aside><div class=page><header class=mobile-navigation-header><div class="flex align-center justify-between"><label for=site-menu-control><img src=/knowledge-base/svg/menu-page.svg class=icon alt="Page Menu"></label>
<strong>Akka Cluster</strong>
<label for=content-menu-control><img src=/knowledge-base/svg/menu-content.svg class=icon alt="Content Menu"></label></div></header><article class=markdown><h1 class=post-title><a href=/knowledge-base/notes/akka_cluster/>Akka Cluster</a></h1><h2 id=akka-cluster>Akka Cluster
<a class=anchor href=#akka-cluster>#</a></h2><p><strong>Scenario:</strong> Make actors communicate across the network.</p><p>Allows actors to communicate across the network, greatly simplifying the process. Each node represents an actor system and they all share the same name.</p><h2 id=akka-cluster-aware-routers>Akka Cluster Aware Routers
<a class=anchor href=#akka-cluster-aware-routers>#</a></h2><p><strong>Scenario</strong>: High workload.</p><p>Scalling vertically has limits. Introducing Akka Cluster Aware Routers, that allows scalling the system horizontally. I.e., large tasks are broken on smaller tasks that are routed to an especific node of our cluster.</p><h2 id=akka-cluster-sharding>Akka Cluster Sharding
<a class=anchor href=#akka-cluster-sharding>#</a></h2><p><strong>Scenario</strong>: Database becomes the bottleneck.</p><p>Many applications leverage the database for strong-consistency. However it may become the source of contention (see <a href=/knowledge-base/notes/amdah_s_law/>Amdah&rsquo;s Law</a>
) as the load increases. We may migrate to a cache service (e.g., Memcached or Redis) but it will eventually become the bottleneck.</p><p>In order to solve this, Akka Cluster Sharding allows distributing Actors across the cluster responsible for managing the state of a especific database entitiy (given a hashing function). With the aid of a single-thread illusion, we can cache the entities in-memory without the risk of desyncronizing with the database, leading to strong consistency. This is great as most applications are read-heavy as opposed to write-heavy.</p><h2 id=akka-distributed-data>Akka Distributed Data
<a class=anchor href=#akka-distributed-data>#</a></h2><p><strong>Scenario</strong>: Critical information that is required continously and we need maintain it. Especially small data sets with infrequent updates that require high availabiltiy.</p><p>Akka Distributed Data is a local, replicated and in-memory data storage. The data is asyncronously replicated to other nodes. The consistency model varies and is <a href=https://doc.akka.io/docs/akka/current/typed/distributed-data.html#read-consistency>configurable</a>
. Through this, we can perform updates from any node without coordination and any concurrent updates will be automatically resolved by a monotic merge function explicitly provided.</p><p>For this end we use a especific data-structure called Conflict Free Replicated Data Types (CRDTs).</p><p>For more, please check <a href=https://doc.akka.io/docs/akka/current/typed/distributed-data.html>here</a>
.</p><h3 id=conflict-free-replicated-data-types--crdts>Conflict Free Replicated Data Types (CRDTs)
<a class=anchor href=#conflict-free-replicated-data-types--crdts>#</a></h3><p>CRDTs are stored in-memory and can be copied to disk to speed up recovery if a replica fails.</p><ul><li>A marker that shows something was deleted.</li><li>Can result in data types that only get larger and never smaller.</li><li>Aka CRDT Garbage</li></ul><p>Limitations CRDT: Do not work with every data type that require a merge function. Some data types are too complex to merge and require the use of <em>tombstone</em>.</p><h3 id=limitations>Limitations
<a class=anchor href=#limitations>#</a></h3><ul><li>It may not be possible depending on the data model due to the merge function.</li><li>Eventual Consistency. Strong consistency is possible at the expense of availability.</li><li>The number of top-level entries should me limited (&lt; 1 million) given that it must be transferred to to the nodes.</li><li>The entity musn&rsquo;t be large given that its full-state may replicated to other nodes.</li></ul><p>For more, please check <a href=https://doc.akka.io/docs/akka/current/typed/distributed-data.html#limitations>here</a>
.</p><h3 id=concrete-use-cases-for-akka-distributed-data><span class="org-todo todo TODO">TODO</span> Concrete use-cases for Akka Distributed Data
<a class=anchor href=#concrete-use-cases-for-akka-distributed-data>#</a></h3><p>The lack of Akka Distributed Data may lead to frequent network requests to fetch as especific entity. However, its usage also requires querying several nodes to look for a quorum. Both options have drawbacks, I am curious on knowing the decision thought behind it.</p><h2 id=akka-address>Akka Address
<a class=anchor href=#akka-address>#</a></h2><p>May be local or remote in the form:
<code>akka://&lt;ActorSystem>@&lt;HostName>:&lt;Post>/&lt;ActorPath></code></p><p>Several protocols are available and depend on the use-case:</p><ul><li><code>aeron-udp</code>: High throughput and low latency.</li><li><code>tcp</code>: Good thorughout and latency but lower.</li><li><code>tls-tcp</code>: When encryption is required.</li></ul><h2 id=joining-a-cluster>Joining a Cluster
<a class=anchor href=#joining-a-cluster>#</a></h2><p>Requires &ldquo;Seed Nodes&rdquo;, i.e., contact nodes. Any node is eligible. Best practice is to use &ldquo;Akka Cluster Bootstrap&rdquo; to avoid setting static seed-nodes in each configuration file.</p><p>Must be enabled! And it does not bring any advantage until we set the application to leverage this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>val</span> loyaltyActorSupervisor <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>ClusterSharding</span><span style=color:#f92672>(</span>system<span style=color:#f92672>).</span>start<span style=color:#f92672>(</span>
   <span style=color:#e6db74>&#34;shared-region-name&#34;</span><span style=color:#f92672>,</span>
    <span style=color:#a6e22e>MyActorActor</span><span style=color:#f92672>.</span>props<span style=color:#f92672>(</span>someProp<span style=color:#f92672>),</span>
    <span style=color:#a6e22e>ClusterShardingSettings</span><span style=color:#f92672>(</span>system<span style=color:#f92672>),</span>
    <span style=color:#a6e22e>MyActorSupervisor</span><span style=color:#f92672>.</span>idExtractor<span style=color:#f92672>,</span>
    <span style=color:#a6e22e>MyActorSupervisor</span><span style=color:#f92672>.</span>shardIdExtractor
  <span style=color:#f92672>)</span>
</code></pre></div><h2 id=akka-cluster-management>Akka Cluster Management
<a class=anchor href=#akka-cluster-management>#</a></h2><p>Set of tools served through a HTTP Api to manage the cluster. Must start after the actor system.</p><p>Must be enabled!</p><h3 id=akka-discovery>Akka Discovery
<a class=anchor href=#akka-discovery>#</a></h3><p>Service to locate and discover services.</p><h3 id=akka-cluster-bootstrap>Akka Cluster Bootstrap
<a class=anchor href=#akka-cluster-bootstrap>#</a></h3><p>Automated seed node discovery using Akka Discovery.</p><h3 id=health-check-endpoints>Health Check Endpoints
<a class=anchor href=#health-check-endpoints>#</a></h3><p>Useful when integrating with orchestrating platforms (e.g., K8S).</p><h2 id=communication>Communication
<a class=anchor href=#communication>#</a></h2><p>It is done by using <a href=/knowledge-base/notes/gossip_protocol/>Gossip Protocol</a>
.</p><h2 id=network-partitions>Network Partitions
<a class=anchor href=#network-partitions>#</a></h2><p>This issue cannot be recovered by simply rebooting the affected node. In order to fix this:</p><ol><li>Decide which partitions needs to be cleaned up - How?</li><li>Shutdown the members</li><li>Inform the cluster that those members are down - <code>PUT -F operation=down /cluster/members/&lt;member address></code>.</li><li>Create new members to replace the old.</li></ol><p>Step 2. is important otherwise it continues to operate unware that it has been removed from the cluster which can lead to multiple copies of the same shard.</p><h2 id=split-brain>Split Brain
<a class=anchor href=#split-brain>#</a></h2><p>Occurs when single cluster splits into two or more distinctive clusters. It normally does not occur unless poor management (not stopping processes that are <em>Down</em>) or configuration (there are strategies to solve this automatically). Can be caused by improper <em>Downing</em> a member leading to the node creating another cluster as the process was not terminated.</p><p>It may also occur with a network partition. If this extend, the <em>Unreachable Nodes</em> will be marked as downed but will not be terminated.</p><p>Simpler solutions may be solved automatically through orchestration platforms that automatically stop the process. More complicated split brains may be solved using <em>Lightbend Split Brain Resolver</em>.</p><h3 id=when-using-sharding-or-singleton-for-data-consistency>When using sharding or singleton for data consistency
<a class=anchor href=#when-using-sharding-or-singleton-for-data-consistency>#</a></h3><p>Each cluster can have a copy of the actor leading to a inconsistency and data corruption specially if both shards have access to the database.</p><h2 id=lighbend-split-brain-resolver>Lighbend Split Brain Resolver
<a class=anchor href=#lighbend-split-brain-resolver>#</a></h2><p>Set of customizable strategies for terminating members in order to avoid Split Brain scenarios. Terminating members allow orchestration platforms to take over and heal the problem.</p><h3 id=static-quorum>Static Quorum
<a class=anchor href=#static-quorum>#</a></h3><p>Fixed sized quorom of node. All nodes will evaluate their situation and <em>Down</em> unreachable. If quorum is set then a smaller cluster will prevail, otherwise the nodes will shutdown themselves. The quorum value must at least <code>n/2 + 1</code>.</p><h3 id=keep-majority>Keep Majority
<a class=anchor href=#keep-majority>#</a></h3><p>Similar to previous but dynamically tracks the size of the cluster.</p><h3 id=keep-oldest>Keep Oldest
<a class=anchor href=#keep-oldest>#</a></h3><p>Monitors the oldest node in the cluster. Members that are not communicating with that node will be marked as down and the nodes will terminate themselves. If the oldest node has crashed so will the cluster but is configurable in a way, that in that case only the oldest will be <em>Downed</em>.</p><h3 id=keep-referee>Keep Referee
<a class=anchor href=#keep-referee>#</a></h3><p>Similar to the other one but designate a specific node as <em>referee</em> (based on its address). As far as I can see, it is not configurable to avoid crashing the cluster if the <em>referee</em> is down.</p><h3 id=down-allows>Down Allows
<a class=anchor href=#down-allows>#</a></h3><p>All nodes terminate themselves relying on good orchestration tools to reduce downtime - Me not like this one.</p><h3 id=lease-majority>Lease Majority
<a class=anchor href=#lease-majority>#</a></h3><p>Reserved for Kubernetes deployments.</p><p>It uses a distributed <em>lock</em> (lock) to make it&rsquo;s decision. Each partition will attempt to obtain it the loser terminates and the winnner remains.</p><p>There is a bit of nice hack (IMO but can&rsquo;t understand exactly how this is achieved) which is that the side that is theoretically smaller will delay the attempt to obtain the lock so that the majority wins.</p><h3 id=some-edge-cases>Some Edge Cases
<a class=anchor href=#some-edge-cases>#</a></h3><ul><li>Indirect connected Edges (for some reason is connected to only one member).</li><li>Unstable nodes (keeps on disconnecting from some nodes).</li></ul><p>These edge-caes are automatically handled.</p><h2 id=orphaned-node>Orphaned Node
<a class=anchor href=#orphaned-node>#</a></h2><p>Is down but not terminated.</p><h2 id=cluster-singleton><span class="org-todo todo TODO">TODO</span> Cluster Singleton
<a class=anchor href=#cluster-singleton>#</a></h2></article><footer class=page-footer></footer><label for=site-menu-control class="hidden site-menu-overlay"></label><label for=content-menu-control class="hidden content-menu-overlay"></label></div><aside class=content-menu><div class=content-menu-content><div class=toc-tags><p class=toc-title>Tags</p><div class=list-item-tag style=background-color:#ffecb3>Akka</div></div><p class=toc-title>Table Of Contents</p><nav id=TableOfContents><ul><li><a href=#akka-cluster>Akka Cluster</a></li><li><a href=#akka-cluster-aware-routers>Akka Cluster Aware Routers</a></li><li><a href=#akka-cluster-sharding>Akka Cluster Sharding</a></li><li><a href=#akka-distributed-data>Akka Distributed Data</a><ul><li><a href=#conflict-free-replicated-data-types--crdts>Conflict Free Replicated Data Types (CRDTs)</a></li><li><a href=#limitations>Limitations</a></li><li><a href=#concrete-use-cases-for-akka-distributed-data><span class="org-todo todo TODO">TODO</span> Concrete use-cases for Akka Distributed Data</a></li></ul></li><li><a href=#akka-address>Akka Address</a></li><li><a href=#joining-a-cluster>Joining a Cluster</a></li><li><a href=#akka-cluster-management>Akka Cluster Management</a><ul><li><a href=#akka-discovery>Akka Discovery</a></li><li><a href=#akka-cluster-bootstrap>Akka Cluster Bootstrap</a></li><li><a href=#health-check-endpoints>Health Check Endpoints</a></li></ul></li><li><a href=#communication>Communication</a></li><li><a href=#network-partitions>Network Partitions</a></li><li><a href=#split-brain>Split Brain</a><ul><li><a href=#when-using-sharding-or-singleton-for-data-consistency>When using sharding or singleton for data consistency</a></li></ul></li><li><a href=#lighbend-split-brain-resolver>Lighbend Split Brain Resolver</a><ul><li><a href=#static-quorum>Static Quorum</a></li><li><a href=#keep-majority>Keep Majority</a></li><li><a href=#keep-oldest>Keep Oldest</a></li><li><a href=#keep-referee>Keep Referee</a></li><li><a href=#down-allows>Down Allows</a></li><li><a href=#lease-majority>Lease Majority</a></li><li><a href=#some-edge-cases>Some Edge Cases</a></li></ul></li><li><a href=#orphaned-node>Orphaned Node</a></li><li><a href=#cluster-singleton><span class="org-todo todo TODO">TODO</span> Cluster Singleton</a></li></ul></nav><nav class=backlinks><p class=toc-title>Mentioned In</p><ul class=item-preview-list><li><a href=/knowledge-base/notes/akka/><div class=item-preview><span class=item-preview-title>Akka</span><br><span class=item-preview-content>Akka # Toolkit and runtime for building highly concurrent, distributed and fault tolerant â€¦</span></div></a></li><li><a href=/knowledge-base/notes/akka_sharding/><div class=item-preview><span class=item-preview-title>Akka Sharding</span><br><span class=item-preview-content>Akka Cluster Sharding # Distribute actors across a cluster:
Entities: The main unit â€¦</span></div></a></li><li><a href=/knowledge-base/notes/consistency_and_availability/><div class=item-preview><span class=item-preview-title>Consistency And Availability</span><br><span class=item-preview-content>Scalability # It can meets increases in demand while remaining responsive.
This is â€¦</span></div></a></li><li><a href=/knowledge-base/notes/gossip_protocol/><div class=item-preview><span class=item-preview-title>Gossip Protocol</span><br><span class=item-preview-content>Some of these text may be interwined with specifities of the Gossip Protocol within Akka â€¦</span></div></a></li></ul></nav></div></aside></main></body></html>