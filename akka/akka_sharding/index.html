<!doctype html><html lang=en dir=ltr><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Akka Cluster Sharding #  Distribute actors across a cluster:
 Entities: The main unit (e.g., UserId) Shards: Holds entities (e.g., each shard holds 10 UserIds). Shard Region: Holds Shards. Shard Coordinator: Manages shards.  Entity #  The main unit is: Entity identified by the EntityId which in essence represents the aggregate root&rsquo;s identifier of a concept of our domain (e.g., UserId) and is unique within the cluster. This leads to Strong Consistency given that Akka provides the single thread illusion."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Akka Sharding"><meta property="og:description" content="Akka Cluster Sharding #  Distribute actors across a cluster:
 Entities: The main unit (e.g., UserId) Shards: Holds entities (e.g., each shard holds 10 UserIds). Shard Region: Holds Shards. Shard Coordinator: Manages shards.  Entity #  The main unit is: Entity identified by the EntityId which in essence represents the aggregate root&rsquo;s identifier of a concept of our domain (e.g., UserId) and is unique within the cluster. This leads to Strong Consistency given that Akka provides the single thread illusion."><meta property="og:type" content="article"><meta property="og:url" content="https://bphenriques.github.io/knowledge-base/akka/akka_sharding/"><title>Akka Sharding | Bruno Henriques</title><link rel=manifest href=https://bphenriques.github.io/knowledge-base/manifest.json><link rel=icon href=https://bphenriques.github.io/knowledge-base/favicon.png type=image/x-icon><link rel=stylesheet href=https://bphenriques.github.io/knowledge-base/book.min.30d3414efaeb1d1ebd7cd338d441a193d2938a6c345cd477aa29b4113001564d.css integrity="sha256-MNNBTvrrHR69fNM41EGhk9KTimw0XNR3qim0ETABVk0="><script defer src=https://bphenriques.github.io/knowledge-base/en.search.min.40ee487373e9e084fe92fdd09f3e7a86ab35d9395e74ac42a853cebb30e353fc.js integrity="sha256-QO5Ic3Pp4IT+kv3Qnz56hqs12TledKxCqFPOuzDjU/w="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=https://bphenriques.github.io/knowledge-base/><span>Bruno Henriques</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Akka</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_actors/>Akka Actors</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_cluster/>Akka Cluster</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_dispatcher/>Akka Dispatcher</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_router/>Akka Router</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_sharding/ class=active>Akka Sharding</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_streams/>Akka Streams</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_testing/>Akka Testing</a></li><li><a href=https://bphenriques.github.io/knowledge-base/akka/akka_overview/>Akka Overview</a></li></ul></li><li class=book-section-flat><span>Concurrency</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/concurrency/actor-model/>Actor Model</a></li><li><a href=https://bphenriques.github.io/knowledge-base/concurrency/amdah_s_law/>Amdah's Law</a></li><li><a href=https://bphenriques.github.io/knowledge-base/concurrency/gunther_s_universal_scalability_law/>Gunther's Universal Scalability Law</a></li></ul></li><li class=book-section-flat><span>Data Processing</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/data-processing/states-of-data/>States of Data</a></li></ul></li><li class=book-section-flat><span>Databases</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/databases/databases_overview/>Databases Overview</a></li><li><a href=https://bphenriques.github.io/knowledge-base/databases/databases_sharding-or-partitioning/>Sharding or Partitioning</a></li></ul></li><li class=book-section-flat><span>Documentation</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/documentation/readme/>Readme</a></li></ul></li><li class=book-section-flat><span>Editors</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/editors/emacs/>Emacs</a></li></ul></li><li class=book-section-flat><span>Learning</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/learning/coursera/>Coursera</a></li><li><a href=https://bphenriques.github.io/knowledge-base/learning/hands_on_scala_programming/>Hands-on Scala Programming</a></li><li><a href=https://bphenriques.github.io/knowledge-base/learning/technical_writing/>Technical Writing</a></li></ul></li><li class=book-section-flat><span>Messaging Systems</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/messaging-systems/messaging-systems-overview/>Messaging Systems Comparison</a></li></ul></li><li class=book-section-flat><span>Monitoring</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/monitoring/bug-management/>Bug Management</a></li></ul></li><li class=book-section-flat><span>Protocols</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/protocols/gossip_protocol/>Gossip Protocol</a></li><li><a href=https://bphenriques.github.io/knowledge-base/protocols/heartbeat/>Heartbeat</a></li></ul></li><li class=book-section-flat><span>Resources</span><ul></ul></li><li class=book-section-flat><span>Security</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/security/jwt/>JWT</a></li><li><a href=https://bphenriques.github.io/knowledge-base/security/password_management/>Password Management</a></li></ul></li><li class=book-section-flat><span>System Design</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/system-design/base_transaction/>BASE Transaction</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/command_query_responsibility_segregation/>Command Query Responsibility Segregation (CQRS)</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/command_sourcing/>Command Sourcing</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/>Consistency And Availability</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/>Domain Driven Design</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/event_sourcing_es_es/>Event Sourcing (ES)</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/>Message Driven Architecture</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/microservices/>Microservices</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/monolith/>Monolith</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/reactive_streams/>Reactive Streams</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/reactive_systems/>Reactive Systems</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/saga/>Saga</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture_soa/>Service Oriented Architecture (SOA)</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/system-design_sli-slo/>SLI/SLO</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/system-design_stateless/>Stateless</a></li></ul></li><li class=book-section-flat><span>Work</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/work/curriculum/>Curriculum</a></li><li><a href=https://bphenriques.github.io/knowledge-base/work/random-memories/>Random Memories</a></li><li><a href=https://bphenriques.github.io/knowledge-base/work/thinking_tools/>Thinking Tools</a></li><li><a href=https://bphenriques.github.io/knowledge-base/work/way-of-work/>Way of work</a></li></ul></li><li class=book-section-flat><span>Snippets</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/snippets/git/>Git</a></li><li><a href=https://bphenriques.github.io/knowledge-base/snippets/gpg/>GPG</a></li><li><a href=https://bphenriques.github.io/knowledge-base/snippets/jackson/>Jackson</a></li><li><a href=https://bphenriques.github.io/knowledge-base/snippets/scala_experiments/>Scala Experiments</a></li></ul></li><li class=book-section-flat><span>Blog Ideas</span><ul></ul></li><li class=book-section-flat><span>Uncategorized</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/nix/>Nix</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/web-stack-enties/>Stack Web Notes</a></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=https://bphenriques.github.io/knowledge-base/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Akka Sharding</strong>
<label for=toc-control><img src=https://bphenriques.github.io/knowledge-base/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#akka-cluster-sharding>Akka Cluster Sharding</a><ul><li><a href=#entity>Entity</a></li><li><a href=#shards>Shards</a></li><li><a href=#shard-region>Shard Region</a></li><li><a href=#shard-coordinator>Shard Coordinator</a></li></ul></li><li><a href=#from-stateless-systems-to-stateful-systems>From Stateless systems to Stateful systems</a><ul><li><a href=#stateful-actors>Stateful Actors</a></li></ul></li><li><a href=#passivation>Passivation</a></li><li><a href=#rebalancing>Rebalancing</a><ul><li><a href=#remember-entities>Remember Entities</a></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=akka-cluster-sharding>Akka Cluster Sharding
<a class=anchor href=#akka-cluster-sharding>#</a></h2><p>Distribute actors across a cluster:</p><ul><li><em>Entities</em>: The main unit (e.g., <code>UserId</code>)</li><li><em>Shards</em>: Holds entities (e.g., each shard holds 10 <code>UserIds</code>).</li><li><em>Shard Region</em>: Holds Shards.</li><li><em>Shard Coordinator</em>: Manages shards.</li></ul><h3 id=entity>Entity
<a class=anchor href=#entity>#</a></h3><p>The main unit is: Entity identified by the <code>EntityId</code> which in essence represents the aggregate root&rsquo;s identifier of a concept of our domain (e.g., <code>UserId</code>) and is unique within the cluster. This leads to <em>Strong Consistency</em> given that Akka provides the single thread illusion.</p><p>The <code>EntityId</code> is extracted through the <code>ExtractEntityId</code> partial function. This is often modeled using a <code>Envelope</code> (which is not mandatory <span class=underline>when</span> the message contains the identifier):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Envelope</span><span style=color:#f92672>(</span>entityId<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>,</span> message<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Any</span><span style=color:#f92672>)</span>

<span style=color:#66d9ef>val</span> idExtractor<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ExtractEntityId</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
   <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Envelope</span><span style=color:#f92672>(</span>id<span style=color:#f92672>,</span> msg<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#f92672>(</span>id<span style=color:#f92672>,</span> msg<span style=color:#f92672>)</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>The name of the actor essentially becomes the <code>EntityId</code>.</p><h3 id=shards>Shards
<a class=anchor href=#shards>#</a></h3><p>In turn, these entities are grouped into shards. The distribution depends on the its identifiers (<code>ShardId</code>) are generated which is usually based on <code>EntityId</code>. An improper distribution leads to a unbalanced cluster, which leads to hotspots (e.g., names, dates, auto-incrementing ids). As rule of thumb, use ~10 shards per node as too many may be costly to find them and too short reduces the capability to distribute them.</p><p>In general, the identifier shard identifier is modelled as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>val</span> shardIdExtractor<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ExtractShardId</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Envelope</span><span style=color:#f92672>(</span>id<span style=color:#f92672>,</span> <span style=color:#66d9ef>_</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Math</span><span style=color:#f92672>.</span>abs<span style=color:#f92672>(</span>id<span style=color:#f92672>.</span>hashCode <span style=color:#f92672>%</span> totalShards<span style=color:#f92672>)).</span>toString
<span style=color:#f92672>}</span>
</code></pre></div><h3 id=shard-region>Shard Region
<a class=anchor href=#shard-region>#</a></h3><p>For a type of entity, there is usually one Shard Region per JVM, in other words, we instantiate a shard region (for a given actor type) on every node that we want to host shards. Alternatively, we may merely create a proxy to a shard region. Last but not the least, a shard region is a <code>ActorRef</code> that we can send messages as usual.</p><h3 id=shard-coordinator>Shard Coordinator
<a class=anchor href=#shard-coordinator>#</a></h3><p>Manages shards. It is responsible to route the messages addressed to a specific entity. It provides the location of the shard which can then be used to acccess the entity.</p><p>Runs as an Akka Cluster singleton and it does not do much of work therefore rarely becomes a bottleneck.</p><h2 id=from-stateless-systems-to-stateful-systems>From Stateless systems to Stateful systems
<a class=anchor href=#from-stateless-systems-to-stateful-systems>#</a></h2><p>Strong consistency in a stateless system is done by leveraging a DB as the source of truth, to maintain <em>Strong Consistency</em>. However, as the system grows the DB may become a bottleneck. We can leverage Sharding:</p><ul><li>Load is distributed across multiple machines in the cluster.</li><li>State can be cached for fast access with no need to read from DB.</li><li><em>Strong Consistency</em> is guaranteed by sharded actors backed by the single thread illusion.</li></ul><p>The actors may now become a source of contention, however it is distributed across multiple machines. This means that the system is <em>Elastic</em> and we can scale as needed.</p><p>When there is a failure, it is located in a single actor - <em>Bulkheading</em>.</p><h3 id=stateful-actors>Stateful Actors
<a class=anchor href=#stateful-actors>#</a></h3><p>Read may be done directly from the state. But writes may have to go through the DB followed by a update of our internal state. This is important as when the Actor fails, we need to rebuild our internal state from DB.</p><p>In order to avoid blocking the system while reading from the DB we can use the <code>Stash</code> to store incoming messages until we rebuild the internal state. See following example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyActor</span><span style=color:#f92672>(</span>repository<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Repository</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Actor</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Stash</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>var</span> state<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>State</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>None</span>

    repository<span style=color:#f92672>.</span>read<span style=color:#f92672>(</span>id<span style=color:#f92672>)</span>                 <span style=color:#75715e>// Non-blocking DB. Asyncronous read from DB.
</span><span style=color:#75715e></span>      <span style=color:#f92672>.</span>map<span style=color:#f92672>(</span>state <span style=color:#66d9ef>=&gt;</span> <span style=color:#a6e22e>StateLoaded</span><span style=color:#f92672>(</span>state<span style=color:#f92672>))</span> <span style=color:#75715e>// Notify so that we can change the current context
</span><span style=color:#75715e></span>      <span style=color:#f92672>.</span>pipeTo<span style=color:#f92672>(</span>self<span style=color:#f92672>)</span>

    <span style=color:#66d9ef>def</span> receive<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Receive</span> <span style=color:#f92672>=</span> loading

    <span style=color:#66d9ef>def</span> loading<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Receive</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>StateLoaded</span><span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span>
	state <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Some</span><span style=color:#f92672>(</span>s<span style=color:#f92672>)</span>
	unstashAll <span style=color:#75715e>// read all accumulated messages as soon as we process this message
</span><span style=color:#75715e></span>	context<span style=color:#f92672>.</span>become<span style=color:#f92672>(</span>running<span style=color:#f92672>)</span>
      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>State</span><span style=color:#f92672>.</span>failure<span style=color:#f92672>(</span>ex<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#66d9ef>throw</span> ex <span style=color:#75715e>// Best practice: trigger the restart of the actor by default. The stashed messages are not lost.
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> stash<span style=color:#f92672>()</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>def</span> running<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Receive</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
       <span style=color:#75715e>//regular handler
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Now when we introduce operations that need to update the DB we need to fine-tune this.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UpdateState</span><span style=color:#f92672>(</span>foo<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span>
<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StateUpdated</span><span style=color:#f92672>(</span>state<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>State</span><span style=color:#f92672>])</span>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyActor</span><span style=color:#f92672>(</span>repository<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Repository</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Actor</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Stash</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>var</span> state<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>State</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>None</span>

    repository<span style=color:#f92672>.</span>read<span style=color:#f92672>(</span>id<span style=color:#f92672>)</span>                 <span style=color:#75715e>// Non-blocking DB. Asyncronous read from DB.
</span><span style=color:#75715e></span>      <span style=color:#f92672>.</span>map<span style=color:#f92672>(</span>state <span style=color:#66d9ef>=&gt;</span> <span style=color:#a6e22e>StateLoaded</span><span style=color:#f92672>(</span>state<span style=color:#f92672>))</span> <span style=color:#75715e>// Notify so that we can change the current context
</span><span style=color:#75715e></span>      <span style=color:#f92672>.</span>pipeTo<span style=color:#f92672>(</span>self<span style=color:#f92672>)</span>

    <span style=color:#66d9ef>def</span> receive<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Receive</span> <span style=color:#f92672>=</span> loading

    <span style=color:#66d9ef>def</span> loading<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Receive</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>StateLoaded</span><span style=color:#f92672>(</span>s<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span>
	state <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Some</span><span style=color:#f92672>(</span>s<span style=color:#f92672>)</span>
	unstashAll <span style=color:#75715e>// read all accumulated messages as soon as we process this message
</span><span style=color:#75715e></span>	context<span style=color:#f92672>.</span>become<span style=color:#f92672>(</span>running<span style=color:#f92672>)</span>
      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>State</span><span style=color:#f92672>.</span>failure<span style=color:#f92672>(</span>ex<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#66d9ef>throw</span> ex <span style=color:#75715e>// Best practice: trigger the restart of the actor by default. The stashed messages are not lost.
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> stash<span style=color:#f92672>()</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>def</span> running<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Receive</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>UpdateState</span><span style=color:#f92672>(</span>foo<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span>
	context<span style=color:#f92672>.</span>become<span style=color:#f92672>(</span>waiting<span style=color:#f92672>)</span>
	repository<span style=color:#f92672>.</span>update<span style=color:#f92672>(</span>state<span style=color:#f92672>.</span>copy<span style=color:#f92672>(</span>foo <span style=color:#66d9ef>=</span> foo<span style=color:#f92672>))</span>
	  <span style=color:#f92672>.</span>map<span style=color:#f92672>(</span><span style=color:#a6e22e>StateUpdate</span><span style=color:#f92672>.</span>apply<span style=color:#f92672>)</span>
	  <span style=color:#f92672>.</span>pipeTo<span style=color:#f92672>(</span>self<span style=color:#f92672>)(</span>sender<span style=color:#f92672>())</span> <span style=color:#75715e>// send message to self as soon as the operation is done with the original sender() to reply back to
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>def</span> waiting<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Receive</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>case</span> evt <span style=color:#66d9ef>@</span> <span style=color:#a6e22e>StateUpdate</span><span style=color:#f92672>(</span>state<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span>
	unstashAll<span style=color:#f92672>()</span>              <span style=color:#75715e>// enqueue messages not processed while the DB was being written.
</span><span style=color:#75715e></span>	context<span style=color:#f92672>.</span>become<span style=color:#f92672>(</span>running<span style=color:#f92672>)</span>   <span style=color:#75715e>// can process messages as usual
</span><span style=color:#75715e></span>	sender<span style=color:#f92672>()</span> <span style=color:#f92672>!</span> evt            <span style=color:#75715e>// reply back to the original sender
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>case</span> failure <span style=color:#66d9ef>@</span> <span style=color:#a6e22e>Status</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Failure</span><span style=color:#f92672>(</span>ex<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span>
	log<span style=color:#f92672>.</span>error<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;[orderId] FAILURE: </span><span style=color:#e6db74>${</span>ex<span style=color:#f92672>.</span>getMessage<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span>
	sender<span style=color:#f92672>()</span> <span style=color:#f92672>!</span> failure        <span style=color:#75715e>// make sure we reply back
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>throw</span> ex                  <span style=color:#75715e>// trigger actor restart
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span>
	stash<span style=color:#f92672>()</span>

<span style=color:#f92672>}</span>
</code></pre></div><h2 id=passivation>Passivation
<a class=anchor href=#passivation>#</a></h2><p>This fenomenon can be observer through small dips in the throughput. This happens as the Actors attempts to manage the number of actors in-memory as keep all of them is unreasonable. E.g., idle actors.</p><p>Each actor tracks the time it processed a message. If it hadn&rsquo;t processed a message within a configured time period, it will <em>Passivate</em>, leading to the removal of the actor in-memory.</p><p>The period must be tune-up, too long may lead to OOM and too short may lead to constant reads from the DB. Best practise is to determine and then tune up by watching the memory usage.</p><p>It can also be done manually by sending a <em>Passivate</em> message to the parent.</p><h2 id=rebalancing>Rebalancing
<a class=anchor href=#rebalancing>#</a></h2><p>Occurs whenever the size of the cluster changes. The Shard coordinator will initiate the rebalancing process by distributing the shards across the all available nodes in order to keep an even distribution of entities.</p><p>This can only occur in a healthy cluster. Therefore any unreachable nodes must be removed (and terminated <strong>before</strong>) either manually through <em>Akka Management</em> or using the <em>Lightbend Split Brain Resolver</em>.</p><p>Steps:</p><ol><li>Coordinator informs Regions that a rebalance has started.</li><li>Messages to an entity on a moving shard are buffered.</li><li>Oce shared was rebalanced, the queued messages are sent</li></ol><p>During rebalancing, the messages delivered follow the <em>at-most-once</em> semantics.</p><p>There are several Shard Allocation Strategies, the default one is <code>LeastShardAllocationStrategy</code>.</p><p>However, the <span class=underline><strong>shards are not automatically restarted</strong></span>. In order for it to happen one needs to use &ldquo;Remember Entities&rdquo; with some costs.</p><h3 id=remember-entities>Remember Entities
<a class=anchor href=#remember-entities>#</a></h3><p>By enabling <code>remember-entities</code>, when a node restarts/rebalances, it will restore entities. This works by informing every member every time each entity starts or stops (using Akka distributed data) and stored in a durable storage in the disk (it can be recovered even after full cluster restart). However, this be disabled on environments without persistent storage (e.g., Kubernetes), in those cases use <code>eventsourced</code> data mode (see <a href=https://doc.akka.io/docs/akka/current/typed/cluster-sharding.html>documentation</a>).</p><p>Warning!</p><ul><li>Enabling this disables <strong>automatic</strong> passivation.</li><li>It is not cheap as every node will have to be informed of all running entities, which leads to an overhead starting/stopping them.</li></ul><p>Best practice is to limit when we have a limited number of active entities. Most of times is not really needed as entities will be removed automatically through <em>Passivation</em> brought back when needed. However some use-cases:</p><ul><li>When the entity has a scheduled process that may not have completed.</li><li>When the time to restart an entity on demand could cause the system to backup (long startup times).</li><li>When the resource savings of passivating the Entities are insignificant.</li></ul><p>With this feature, the node&rsquo;s <code>ExtractShardId</code> function must handle <code>ShardRegion.StartEntity(entityId)</code>.</p><p>Note: During startup, some nodes may become overwhelmed. In order to avoid concentrating the shards on a single member of the cluster we set the minimum number of members under cluster settings. This allows unnecessary rebalances during the startup. While the cluster has not enough members, existing members will remain in the <em>Join</em> state.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div><a class="flex align-center" href=https://github.com/bphenriques/knowledge-base/edit/master/org/akka/akka_sharding.org target=_blank rel=noopener><img src=https://bphenriques.github.io/knowledge-base/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#akka-cluster-sharding>Akka Cluster Sharding</a><ul><li><a href=#entity>Entity</a></li><li><a href=#shards>Shards</a></li><li><a href=#shard-region>Shard Region</a></li><li><a href=#shard-coordinator>Shard Coordinator</a></li></ul></li><li><a href=#from-stateless-systems-to-stateful-systems>From Stateless systems to Stateful systems</a><ul><li><a href=#stateful-actors>Stateful Actors</a></li></ul></li><li><a href=#passivation>Passivation</a></li><li><a href=#rebalancing>Rebalancing</a><ul><li><a href=#remember-entities>Remember Entities</a></li></ul></li></ul></nav></div></aside></main></body></html>