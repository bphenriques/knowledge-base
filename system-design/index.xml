<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>System Design on Bruno Henriques</title><link>https://bphenriques.github.io/knowledge-base/system-design/</link><description>Recent content in System Design on Bruno Henriques</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://bphenriques.github.io/knowledge-base/system-design/index.xml" rel="self" type="application/rss+xml"/><item><title>Consistency And Availability</title><link>https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/</guid><description>Scalability It can meets increases in demand while remaining responsive.
This is different from performance. Performance optimizes response time (latency) while scalability optimizes ability to handle load. Requests per second actually measures both but we do not know which aspect was improved.
Note Scalability is not the number of requests qwe can handle a in a given period of time (req/sec) but he number of requests itself (load).
If x axis is number of requests (Load) and y axis is response time.</description></item><item><title>Distributed Systems</title><link>https://bphenriques.github.io/knowledge-base/system-design/distribute_systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/distribute_systems/</guid><description>Definition: Systems that are separated by space.
Issue: Consistency. By the time the receiver receives the state of the sender, the state may have already changed!</description></item><item><title>Domain Driven Design</title><link>https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/</guid><description>Referred in
Microservices See raw in Lightbend Academy
Useful for modelling use-cases before attempting to implement it whether in Software or mere Diagrams.
Subject-Verb-Object notation Allows having a consistent way to phrase activies our events in the domain.
Example: Host checks current reservation.
Subject: Host Verb: Checks Object: Reservation Note that &amp;ldquo;current&amp;rdquo; can be seen as a modifier.
Sometimes there may be multiple objects. E.</description></item><item><title>Message Driven Architecture</title><link>https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/</guid><description>Asyncronous and non-blocking. The sender does not actively wait for a response.
Advantages:
Resources are freed immediatly. Reduced contention Messages can be queued for deleivery in case the receiver&amp;rsquo;s is offline. Provides a higher level of reliability. Disavantages:
Make transactions more difficult. How to manage long running transactions that span multiple microservices. Holding transactions open for long periods result in slow, brittle systems. The role of syncronous messags:</description></item><item><title>Microservices</title><link>https://bphenriques.github.io/knowledge-base/system-design/microservices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/microservices/</guid><description>Subset of Service Oriented Architecture where each service is deployed separately:
Microservices can be physically separated and independently deployed. Each have its own data store. Independent and self governing. Communication is syncronous or asyncronous (e.g., through message brokers). Loose coupling between components (more or less by experience but that is design flaw likely :thinking:). Shorter development and release cycles. Each scale independently (either through physical or virtual machines). Advantages Deployed/Scaled as needed.</description></item><item><title>Monolith</title><link>https://bphenriques.github.io/knowledge-base/system-design/monolith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/monolith/</guid><description>Referred in
Service Oriented Architecture Some notes taken during the lightbend course on Reactive Microservices. Some of these ideas are familiar as they are intuitive.
Deployed as a single unit. No Clear Isolation. Complex Depedencies -&amp;gt; Hard to understand and modify. Communication using syncronous calls. Hmmm, I disagree and I think that it depends.. E.g., Spring allows services call another with asyncronous methods within the same monolith.</description></item><item><title>Service Oriented Architecture</title><link>https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture/</guid><description> Referred in
Monolith Microservices As opposed to Monolith, services do not share a database and all access must be done through a API exposed by the service. They may be in the same process (monolith) or may be separated (microservices). This reduces coupling.
E.g.:
Orders -&amp;gt; RDBMS Customers -&amp;gt; No SQL Reservations -&amp;gt; Web Service Menu -&amp;gt; RDBMS</description></item></channel></rss>