'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/knowledge-base/concurrency/actor-model/','title':"Actor Model",'content':" Referred in\n Lightbend Academy   In the context of Reactive Systems, Actor model is a reactive tool, a paradigm that:\n Message driven - All communication between actors is done with async non-blocking messages. Abstractions provide elasticity and resiliency.  Akka uses the actor model - https://doc.akka.io/docs/akka/current/typed/guide/actors-intro.html?language=scala\nFundamental  All computation occurs inside of the actor. Each actor has an address. Actors only communicate through asyncronous messages.  The message driven system provides location transparency, i.e., the technique remainins the same regardless of where the actors are. This allows better resiliency and elastic (hmm.. questions on this bit). This is different from \u0026ldquo;Transparent remoting\u0026rdquo; as this hides potential networking issues while making it seem like local calls. Location transparency makes the opposite which is makes local calls seem like remote calls, therefore whoever uses is aware that there are potential failures.\n"});index.add({'id':1,'href':'/knowledge-base/data-processing/apache-spark/','title':"Apache Spark",'content':"Glossary  RDD - Resilient Distributed Datasets  "});index.add({'id':2,'href':'/knowledge-base/monitoring/bug-management/','title':"Bug Management",'content':"Some personal notes on simplifying the process so that one can focus on getting back to the other tasks at hand.\nOn Reporting Bugs  Focus on the impact for the client. You do not need to debug right away. You do not need to establish the timeline - The report can solely include the context. The person assigned to the issue will pick on the context provided in the ticket and explore.  "});index.add({'id':3,'href':'/knowledge-base/concurrency/','title':"Concurrency",'content':""});index.add({'id':4,'href':'/knowledge-base/tools/cost-comparison/','title':"Cost Comparison",'content':"Not sure the best place to place this.\nComparing if it is worth purchasing a service https://isitworththecost.com/\n"});index.add({'id':5,'href':'/knowledge-base/data-processing/','title':"Data Processing",'content':""});index.add({'id':6,'href':'/knowledge-base/documentation/','title':"Documentation",'content':""});index.add({'id':7,'href':'/knowledge-base/jvm/jackson/','title':"Jackson",'content':"After working a while with this I want to register these sane defaults:\nconfigure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true) configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false) Setting FAIL_ON_NULL_FOR_PRIMITIVES forces clients to explicitely provide all values including primitives. Consider the following POJO:\ndata class(foo: Boolean) Without the setting, this would set foo as false during serialization despite the lack of default value. Given this, to guarantee consistency between the source-code and the external contract, I advise enabling this.\nSetting FAIL_ON_UNKNOWN_PROPERTIES is useful when working on two systems in paralel. Settings this to false enables clients to send fields to the server that are not yet supported but will be. The alternative would be:\n Server includes those fields as optional fields (to avoid breaking current clients). Server roll-out. Clients update their HTTP clients to include the new fields. Once all-known clients support the new fields, make the same fields mandatory.  By setting this to true, this whole orchestration is not required.\n"});index.add({'id':8,'href':'/knowledge-base/jvm/','title':"JVM",'content':""});index.add({'id':9,'href':'/knowledge-base/messaging-systems/','title':"Messaging Systems",'content':""});index.add({'id':10,'href':'/knowledge-base/monitoring/','title':"Monitoring",'content':""});index.add({'id':11,'href':'/knowledge-base/messaging-systems/overview/','title':"Overview",'content':"Kafka Event Streaming, persistent.\nRabbitMQ Low latency.\nPulsar Made by Apache\nTODO   Read this comparison: https://www.confluent.io/kafka-vs-pulsar/#:~:text=In%20reality%2C%20Kafka%2C%20RabbitMQ%2C,Pulsar%20sits%20somewhere%20in%20between.  "});index.add({'id':12,'href':'/knowledge-base/documentation/readme/','title':"readme",'content':"Several examples   https://github.com/matiassingers/awesome-readme\nKey take-ways of some:\n Logo top TOC (horizontally) Demo (!) How to use LICENCE  Like minimalistic versions as they require less maintenance (hmmm :thinking-face:)\n  "});index.add({'id':13,'href':'/knowledge-base/work/short-sentence-reminder/','title':"short-sentence-reminder",'content':"Kinda short sentences? Some things are pretty obvious (:\n Failure in systems are inevitable. We have to accept and build a system that isolates such failures in a way that becomes unnoticible to the end-user. User does not care whether the software was faulty due to a third-party vender or not. When we build software we have to consider third-party vendors and if we don\u0026rsquo;t properly isolate ourselves from their faulty behavior, users are going to pay for that.     Responsiveness builds user confidence.\n  Domain: Sphere of knowledge that models either a business or an idea.\n  "});index.add({'id':14,'href':'/knowledge-base/data-processing/states-of-data/','title':"States of Data",'content':"States of data:\n At Rest: Data that is not consumed at the time is injested. It is stored and then consumed later in a batch process. In Transit: Data that is travelling between point A and point B. In Use: Data that is opened for treatment  Encountered several concerns regarding how such data must be handled. Follows a link to be reviewed later:three-states-of-data\n"});index.add({'id':15,'href':'/knowledge-base/work/tips-to-live-by/','title':"Tips to live by",'content':"It\u0026rsquo;s not about being right nor prove others wrong  Corollary 1: if it\u0026rsquo;s wrong but it works, then it\u0026rsquo;s not wrong. Corollary 2: if you\u0026rsquo;re right but it doesn\u0026rsquo;t change the outcome, then it doesn\u0026rsquo;t matter. Corollary 3: if you\u0026rsquo;re right, but it doesn\u0026rsquo;t work, then you\u0026rsquo;re wrong. Corollary 4: if you prove someone else wrong, but their answer works and yours doesn\u0026rsquo;t, then they\u0026rsquo;re right and you\u0026rsquo;re wrong. Corollary 5: if you prove someone\u0026rsquo;s solution to be wrong even though it does provide value, then you have not yet provided any value until you propose something better.  "});index.add({'id':16,'href':'/knowledge-base/tools/','title':"Tools",'content':""});index.add({'id':17,'href':'/knowledge-base/work/','title':"Work",'content':""});index.add({'id':18,'href':'/knowledge-base/uncategorized/lightbend-academy/','title':"Lightbend Academy",'content':"Some notes regarding Lighbend academy at https://academy.lightbend.com/. Taking this opportunity as it is free during this summer.\nHope to learn more about Reactive + Akka + Actors + Streams.\nHmmm\u0026hellip; is Data Engineering something I would like to work with? :thinking:\nGlossary  Data at Rest: Data that is not consumed at the time is injested. It is stored and then consumed later in a batch process.  Introduction to Reactive Systems Context: Increasing complexity which requires many nodes (2-3 on simpler) and far more nodes on more complex systems. And the amount of data that is handled today is far larger that it was before, in order to petabytes and is no longer rest, i.e., is actively changing making very hard to catch up.\nGoal: Provide an experience that is responsive under all conditions:\n Scale from 10 users to million of users. Consume solely the resources required to support the current work-load (IMO this does not say much, maybe they are referring to the lack of batch jobs that periodically run?) It scales horizontally across several nodes Consistent level of quality and responsiveness  Well.. they provide some explanations regarding avoiding downtime, I am curious which use-cases where this architecture solves as they are use-cases where this can be tricky.\nReactor Principles  Most important: Responsive - Always respond in a timely manner. Leads to have to be resiliency even when failures occur. Elastic to keep responsive specially when the system load changes - goes both ways as keeping lots of resources is expensive specially when unjustified. Foundation on Message Driven (or event driven in reactive manifesto) - Async and non-blocking message.  On resiliency: Achieved through:\n Replication Isolation Containment Delegation  Isolation on single components. Recovery is delegated to an external component. Hmmm, kinda reminds me k8s when it detects Pods as not ready and forwards traffic to the remaining pods.\nOn Elasticicity Responsivess regardless of the load. Zero contention and no central bottlenecks - Seems like to be good be true despite possible. Well.. isn\u0026rsquo;t what we always want regardless of the architecture? Predictive Auto-Scaling techniques. Responsiveness during peaks while scaling down assures cost effectivness without losing responsiviness.\nOn MEssage Driven All previous principles are supported by this. Loose coupling, isolation and location transparency - I kinda disagree with loose coupling, as the systems still will still depend on 3rd party behavior regardless of the communication medium. Resources are only consumed while active. Idea is that we we stop using resources while waiting for an system to respond, we can do something else while the response haven\u0026rsquo;t arrived (async)\nReactive Principles Example - git Git is a good example regarding reactive principles:\n Asyncronous and non-blocking as the work is submitted through PR and I can keep on working locally with no interruptions. Message based as it is basically \u0026ldquo;please review this\u0026rdquo;. SeeActor Model. Resiliency as each user has basically a copy of the whole repository locally. The local machine is isolated from the remote. Elastic has we can have multiple copies and does not cause problemas having that repository sync on that many machines. Responsive.  Reactive Programming vs Reactive Systems They are not the same.\nReactive systems apply the reactive principles on a architectural level.\nReactive Programming can be (and often is) used to build reactive systems but that does not mean that it is a reactive system.\nIn order to have a reactive architecture, it means that the reactive systems needs to be separated thorugh asyncronous boundaries.\nTODO https://www.lightbend.com/white-papers-and-reports/reactive-programming-versus-reactive-systems Domain Driven Design Goal: Software implementation that is based on an evolving model that is understood by the domain experts.\nOther TODO There is a thing called Reactive Manifesto https://github.com/reactivemanifesto/reactivemanifesto\n"});index.add({'id':19,'href':'/knowledge-base/uncategorized/relevant-xkcds/','title':"Relevant xkcds",'content':"On Standards https://xkcd.com/927/\n"});index.add({'id':20,'href':'/knowledge-base/uncategorized/','title':"Uncategorized",'content':""});})();