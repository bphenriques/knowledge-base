<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>akka on Bruno Henriques's Digital Garden ðŸŒ±</title><link>https://bphenriques.github.io/knowledge-base/tags/akka/</link><description>Recent content in akka on Bruno Henriques's Digital Garden ðŸŒ±</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://bphenriques.github.io/knowledge-base/tags/akka/index.xml" rel="self" type="application/rss+xml"/><item><title>Akka</title><link>https://bphenriques.github.io/knowledge-base/notes/akka/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka/</guid><description>Akka # Toolkit and runtime for building highly concurrent, distributed and fault tolerant message-driven application in the JVM. It can be used to build Reactive Systems. Proposes unified programming model for:
Simpler concurrency: single threaded illusion as each actor processes a message at a time (no need to locks or synchronization strategies). Simpler distribution: is distributed by default (see more on Akka Cluster ). Simpler fault tolerance: Decouples communication from failure handling.</description></item><item><title>Akka Actors</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_actors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_actors/</guid><description>Handling Messages Asyncronously # Blocking threads inside the actors creates contention therefore the handling of the messages must happen in a async fashion, including any DB writes and DB reads when starting the actor. For example, using interfaces such as Future[T]. However this may lead to concurrency within the actor itself removing the ilusion of a single thread. This means that messages must be stash until other operations complete.</description></item><item><title>Akka Cluster</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_cluster/</guid><description>Akka Cluster # Scenario: Make actors communicate across the network.
Allows actors to communicate across the network, greatly simplifying the process. Each node represents an actor system and they all share the same name.
Akka Cluster Aware Routers # Scenario: High workload.
Scalling vertically has limits. Introducing Akka Cluster Aware Routers, that allows scalling the system horizontally. I.e., large tasks are broken on smaller tasks that are routed to an especific node of our cluster.</description></item><item><title>Akka Dispatcher</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_dispatcher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_dispatcher/</guid><description>The engine of Akka as it decides when a actor should process messsages and when it must yield the thread for others. It means that dispatchers are in control of the thread time and of the threads themselves.
Dispatcher (default): Event-driven dispatcher, sharing threads from thread pool. PinnedDispatcher: Dedicated thread per actor. CallingThreadDispatcher: Just for testing. The best tips are:
Adjust throughput to deliver more messages to the actors before yielding.</description></item><item><title>Akka Router</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_router/</guid><description>Intro # In Akka, Router routes messages to destination Akka Actors called routees that can process messages in parallel to improve throughput. The way routing is done may be configured to fit the use-case.
Routing Strategies # Determines how router routes to its routees.
RandomRoutingLogic: Pure random and fast. May be unbalanced. RoundRobinRoutingLogic: Take turns. Is more fair and distributed. But depending on the messages, some actors may have more work than others.</description></item><item><title>Akka Sharding</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_sharding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_sharding/</guid><description>Akka Cluster Sharding # Distribute actors across a cluster:
Entities: The main unit (e.g., UserId) Shards: Holds entities (e.g., each shard holds 10 UserIds). Shard Region: Holds Shards. Shard Coordinator: Manages shards. Entity # The main unit is: Entity identified by the EntityId which in essence represents the aggregate root&amp;rsquo;s identifier of a concept of our domain (e.g., UserId) and is unique within the cluster. This leads to Strong Consistency given that Akka provides the single thread illusion.</description></item><item><title>Akka Streams</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_streams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_streams/</guid><description>Actor Streams leverage the actor system to consume streams of data. In fact, each element of a stream is a Message within the Actor System
Here, data flows through a chain of processing stages:
Sources: The &amp;ldquo;source&amp;rdquo; (e.g., CSV file). Sinks: The &amp;ldquo;destination&amp;rdquo; (e.g., a file). Flows: Transformations made to the data within the Stream (e.g., total number of lines). Runnable Graphs: A stream where all inputs and outputs are connected.</description></item><item><title>Akka Testing</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_testing/</guid><description>How to test actors in Akka.
Test Actor Ref # Synchronous and ideal for white-box testing as we can change the internal state.
Test Probes # Black-box testing and then verify if specific messages were sent (and other assertions).
(black box is always better :) )</description></item></channel></rss>