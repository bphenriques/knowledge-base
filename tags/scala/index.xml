<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>scala on Bruno Henriques's Digital Garden ðŸŒ±</title><link>https://bphenriques.github.io/knowledge-base/tags/scala/</link><description>Recent content in scala on Bruno Henriques's Digital Garden ðŸŒ±</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://bphenriques.github.io/knowledge-base/tags/scala/index.xml" rel="self" type="application/rss+xml"/><item><title>Hands-on Scala Programming</title><link>https://bphenriques.github.io/knowledge-base/notes/hands_on_scala_programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/hands_on_scala_programming/</guid><description>Follows my notes on the Haoyi Li.&amp;rsquo;s book: &amp;ldquo;Hands-on Scala Programming&amp;rdquo; (https://www.handsonscala.com/).
As an experiment, I coding directly in the org-mode file using Babel to execute the Scala blocks:
TODO Some introduction # Point to dotfiles Point to the Babel package Notes # Lack of auto-complete when writing here. Compilation errors are hard to track. Workaround is to open a separate buffer with the ammonite REPL console.</description></item><item><title>Referential Transparency</title><link>https://bphenriques.github.io/knowledge-base/notes/referential_transparency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/referential_transparency/</guid><description>Referential transparency: replacing an expression by its bound value doesn&amp;rsquo;t alter the behaviour of your program. This gives huge benefits, which I&amp;rsquo;ll talk about later.
References # https://www.reddit.com/r/scala/comments/8ygjcq/can_someone_explain_to_me_the_benefits_of_io/ https://www.youtube.com/watch?v=x3GLwl1FxcA&amp;amp;t=189s</description></item><item><title>Scala Experiments</title><link>https://bphenriques.github.io/knowledge-base/notes/scala_experiments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/scala_experiments/</guid><description>Implementing Tree # sealed class Tree[T] { def stream(): LazyList[T] = this match { case Leaf(value) =&amp;gt; LazyList(value) case Branch(left, right) =&amp;gt; left.stream() #::: right.stream() } } case class Branch[T](left: Tree[T], right: Tree[T]) extends Tree[T] case class Leaf[T](value: T) extends Tree[T] val tree = Branch( Leaf(1), Branch( Leaf(2), Leaf(3) ) ) val nextInOrder = tree.stream().dropWhile(_ != 2).drop(1).headOption println(nextInOrder)</description></item></channel></rss>