<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Handling Messages Asyncronously #  Blocking threads inside the actors creates contention therefore the handling of the messages must happen in a async fashion, including any DB writes and DB reads when starting the actor. For example, using interfaces such as Future[T]. However this may lead to concurrency within the actor itself removing the ilusion of a single thread. This means that messages must be stash until other operations complete."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Akka Actors"><meta property="og:description" content="Handling Messages Asyncronously #  Blocking threads inside the actors creates contention therefore the handling of the messages must happen in a async fashion, including any DB writes and DB reads when starting the actor. For example, using interfaces such as Future[T]. However this may lead to concurrency within the actor itself removing the ilusion of a single thread. This means that messages must be stash until other operations complete."><meta property="og:type" content="article"><meta property="og:url" content="https://bphenriques.github.io/knowledge-base/notes/akka_actors/"><meta property="article:section" content="notes"><title>Akka Actors | Bruno Henriques's Digital Garden ðŸŒ±</title><link rel=icon href=/knowledge-base/favicon.png type=image/x-icon><link rel=stylesheet href=/knowledge-base/scss/explorer.min.fff1aaee6fb1e5a74069ac1205647344fa7bf178f7f20b3abcf095b18d0c24fe.css integrity="sha256-//Gq7m+x5adAaawSBWRzRPp78Xj38gs6vPCVsY0MJP4=" crossorigin=anonymous><script defer src=/knowledge-base/js/vendor/flexsearch.bundle.js></script><script defer src=/knowledge-base/js/search.min.fa36486e7efe8bf981b7efd64989e6e484efc0ee937e313422b50d3e8926df67.js integrity="sha256-+jZIbn7+i/mBt+/WSYnm5ITvwO6TfjE0IrUNPokm32c=" crossorigin=anonymous></script><script defer src=/knowledge-base/js/clipboard.min.14b9ccf5803971502776b44d95026b084e5fa02a544dc0e4cd86a7db76f691b2.js integrity="sha256-FLnM9YA5cVAndrRNlQJrCE5foCpUTcDkzYan23b2kbI=" crossorigin=anonymous></script></head><body><input type=checkbox class="hidden toggle" id=site-menu-control>
<input type=checkbox class="hidden toggle" id=content-menu-control><main class="container flex"><aside class=site-menu><div class=site-menu-content><nav><h2 class=brand><a class="flex align-center" href=/knowledge-base/><span>Bruno Henriques</span></a></h2><div class=search><input type=text id=search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="search-spinner hidden"></div><ul id=search-results class=item-preview-list></ul></div><a class=site-menu-shortcut-link href=/knowledge-base/notes>Recent Notes</a><p class=site-menu-tags-title><b>Tags</b></p><ul><li><a class=list-tag-item href=/knowledge-base/tags/akka><div class=tag-dot style=background-color:#ffecb3></div>Akka</a></li><li><a class=list-tag-item href=/knowledge-base/tags/concurrency><div class=tag-dot style=background-color:#f5f5f5></div>Concurrency</a></li><li><a class=list-tag-item href=/knowledge-base/tags/data><div class=tag-dot style=background-color:#ffe0b2></div>Data</a></li><li><a class=list-tag-item href=/knowledge-base/tags/data-structures><div class=tag-dot style=background-color:#ffcdd2></div>Data structures</a></li><li><a class=list-tag-item href=/knowledge-base/tags/databases><div class=tag-dot style=background-color:#f1f8e9></div>Databases</a></li><li><a class=list-tag-item href=/knowledge-base/tags/dispatcher><div class=tag-dot style=background-color:#c8e6c9></div>Dispatcher</a></li><li><a class=list-tag-item href=/knowledge-base/tags/editors><div class=tag-dot style=background-color:#ffb74d></div>Editors</a></li><li><a class=list-tag-item href=/knowledge-base/tags/jq><div class=tag-dot style=background-color:#e1f5fe></div>Jq</a></li><li><a class=list-tag-item href=/knowledge-base/tags/json><div class=tag-dot style=background-color:#ffebee></div>JSON</a></li><li><a class=list-tag-item href=/knowledge-base/tags/jvm><div class=tag-dot style=background-color:#90caf9></div>Jvm</a></li><li><a class=list-tag-item href=/knowledge-base/tags/kotlin><div class=tag-dot style=background-color:#ffe57f></div>Kotlin</a></li><li><a class=list-tag-item href=/knowledge-base/tags/lightbend><div class=tag-dot style=background-color:#f0f4c3></div>Lightbend</a></li><li><a class=list-tag-item href=/knowledge-base/tags/monitoring><div class=tag-dot style=background-color:#e3f2fd></div>Monitoring</a></li><li><a class=list-tag-item href=/knowledge-base/tags/note><div class=tag-dot style=background-color:#bbdefb></div>Note</a></li><li><a class=list-tag-item href=/knowledge-base/tags/protocols><div class=tag-dot style=background-color:#ab9df2></div>Protocols</a></li><li><a class=list-tag-item href=/knowledge-base/tags/psql><div class=tag-dot style=background-color:#e0f2f1></div>Psql</a></li><li><a class=list-tag-item href=/knowledge-base/tags/queue><div class=tag-dot style=background-color:#ffebee></div>Queue</a></li><li><a class=list-tag-item href=/knowledge-base/tags/reference><div class=tag-dot style=background-color:#00bfa5></div>Reference</a></li><li><a class=list-tag-item href=/knowledge-base/tags/router><div class=tag-dot style=background-color:#c8e6c9></div>Router</a></li><li><a class=list-tag-item href=/knowledge-base/tags/scala><div class=tag-dot style=background-color:#ffd180></div>Scala</a></li><li><a class=list-tag-item href=/knowledge-base/tags/security><div class=tag-dot style=background-color:#b3e5fc></div>Security</a></li><li><a class=list-tag-item href=/knowledge-base/tags/signing><div class=tag-dot style=background-color:#ffd866></div>Signing</a></li><li><a class=list-tag-item href=/knowledge-base/tags/snippets><div class=tag-dot style=background-color:#e1f5fe></div>Snippets</a></li><li><a class=list-tag-item href=/knowledge-base/tags/stream><div class=tag-dot style=background-color:#d1c4e9></div>Stream</a></li><li><a class=list-tag-item href=/knowledge-base/tags/system-design><div class=tag-dot style=background-color:#ffebee></div>System design</a></li><li><a class=list-tag-item href=/knowledge-base/tags/uncategorized><div class=tag-dot style=background-color:#90caf9></div>Uncategorized</a></li><li><a class=list-tag-item href=/knowledge-base/tags/work><div class=tag-dot style=background-color:#f5f5f5></div>Work</a></li><li><a class=list-tag-item href=/knowledge-base/tags/zettelkasten><div class=tag-dot style=background-color:#e3f2fd></div>Zettelkasten</a></li></ul></nav></div></aside><div class=page><header class=mobile-navigation-header><div class="flex align-center justify-between"><label for=site-menu-control><img src=/knowledge-base/svg/menu-page.svg class=icon alt="Page Menu"></label>
<strong>Akka Actors</strong>
<label for=content-menu-control><img src=/knowledge-base/svg/menu-content.svg class=icon alt="Content Menu"></label></div></header><article class=markdown><h1 class=post-title><a href=/knowledge-base/notes/akka_actors/>Akka Actors</a></h1><h2 id=handling-messages-asyncronously>Handling Messages Asyncronously
<a class=anchor href=#handling-messages-asyncronously>#</a></h2><p>Blocking threads inside the actors creates contention therefore the handling of the messages must happen in a async fashion, including any DB writes and DB reads when starting the actor. For example, using interfaces such as <code>Future[T]</code>. However this may lead to concurrency within the actor itself removing the ilusion of a single thread. This means that messages must be <em>stash</em> until other operations complete.</p><p>In essence the actor has 3 states:</p><ul><li>Loading - Load the state from the DB.</li><li>Running - Regular behavior.</li><li>Waiting.</li></ul><p>Question: If DB fails, then it is recommended to throw the exception leading to a restart of the Actor that in turn will re-read the state from the DB. So:</p><ul><li>It is explained that the stash is not lost, how?</li><li>What happens if there is a persistent issue in the DB? Will there be a loop?</li></ul><h2 id=akka-actor-lifecycle>Akka Actor Lifecycle
<a class=anchor href=#akka-actor-lifecycle>#</a></h2><p>Can be stopped by himself or by others.</p><p>Lifecycle (without faults):</p><pre><code class=language-nil data-lang=nil>hook:preStart() -&gt; started -[stop]-&gt; stopped -&gt; hook:postStop() -&gt; terminated
</code></pre><p>The actor is created assyncronously and available right away through the <code>ActorRef</code>.</p><p>Stopping an actor will:</p><ul><li>Finishes the processing the current message.</li><li>Suspends message processing.</li><li><strong>Stop its children</strong> - See <a href=/knowledge-base/notes/actor-model/>Actor Model</a>
.</li><li>Waits for their termination confirmations and then stops himself.</li></ul><p>How to stop: <code>PoisonPill</code> (<code>context.stop(self())</code>) and <code>actorRef ! Kill</code> messages (throw <code>ActorKilledException</code>). They are <strong>not</strong> appropriate to perform a cleanup before shutting down as the Actor does not &ldquo;see&rdquo; those messages (it is handled internally). It is best to use a dedicated message such as <code>StopMeGraciouslyMessage</code>.</p><h3 id=monitor>Monitor
<a class=anchor href=#monitor>#</a></h3><p><em>Dead Watch</em> allows monitoring another actor&rsquo;s termination (regular <code>Terminated</code> message in the <code>receive</code> block).</p><h2 id=failure-handling>Failure Handling
<a class=anchor href=#failure-handling>#</a></h2><p>Akka deals with failures at the level of the individual actor (bulkheading has it only affects that actor).</p><p>Does not throw the message back to the sender (b/c the sender does not know how to handle it). Instead the error is sent to a responsibile entity (e.g., &ldquo;Manager&rdquo;) that determines the required steps to recover.</p><p>When an actor fails, Akka provides two configurable strategies:</p><ul><li><em>OneForOneStrategy</em>: Only the faulty child is affected.</li><li><em>AllForOneStrategy</em>: All children are affected by one faulty child.</li></ul><p>Both are configured with a <code>type Decider = PartialFunction[Throwable, Directive]</code>. If not defined a directive, then the parent is consired faulty. Where <code>Directive</code>:</p><ul><li>Resume: Resume message processing. Use if the state remains valid.</li><li>Restart: Start a new actor in its place and resume, however all childs are stopped (by default unless <code>preRestart</code> hook is changed). It supports max number of retries and within a time limit.</li><li>Stop.</li><li>Escalate: Delegate the decision to the supervisor&rsquo;s parent.</li></ul><p>By default it is <em>OneForOneStrategy</em> with some directives that are too specific to group here and we can check the documentation. In short, by default, the actor will be restarted. In any case, message processing is suspended.</p><ul><li>All descendants of the actor are suspended.</li><li>The actor&rsquo;s parent handles the failure.</li></ul><p>Proper tuning leads to a self-healing system. Some exceptions are worth stopping the actor while others are worth recovering.</p><h3 id=full-lifecycle>Full Lifecycle
<a class=anchor href=#full-lifecycle>#</a></h3><figure><img src=ox-hugo/_20201012_203109screenshot.png></figure><h2 id=ask-vs-tell>Ask vs Tell
<a class=anchor href=#ask-vs-tell>#</a></h2><p>Ask: <code>actorRef ? Message</code>
Tell: <code>actorRef ! Message</code></p><p>Use Ask when:</p><ul><li>Bridging non-actor code to actor-code (e.g., bridging with HTTP controllers ?).</li><li>We are expecting a response within a timeout. In this case we use <code>actorRef ? Message pipeTo self</code> which in turn will will handle the response, e.g., <code>val receive: Receive = { case MessageResponse => stuff }</code>.</li></ul><p>Use tell when:</p><ul><li>We do not care about the response.</li></ul><p>Neverthless, when using the ask operator, always ue pipeTo within the actor system to avoid breaking the single thread illusion.</p><h2 id=testing>Testing
<a class=anchor href=#testing>#</a></h2><p>See <a href=/knowledge-base/notes/akka_testing/>Akka Testing</a>
.</p></article><footer class=page-footer></footer><label for=site-menu-control class="hidden site-menu-overlay"></label><label for=content-menu-control class="hidden content-menu-overlay"></label></div><aside class=content-menu><div class=content-menu-content><div class=toc-tags><p class=toc-title>Tags</p><div class=list-item-tag style=background-color:#ffecb3>Akka</div></div><p class=toc-title>Table Of Contents</p><nav id=TableOfContents><ul><li><a href=#handling-messages-asyncronously>Handling Messages Asyncronously</a></li><li><a href=#akka-actor-lifecycle>Akka Actor Lifecycle</a><ul><li><a href=#monitor>Monitor</a></li></ul></li><li><a href=#failure-handling>Failure Handling</a><ul><li><a href=#full-lifecycle>Full Lifecycle</a></li></ul></li><li><a href=#ask-vs-tell>Ask vs Tell</a></li><li><a href=#testing>Testing</a></li></ul></nav><nav class=backlinks><p class=toc-title>Mentioned In</p><ul class=item-preview-list><li><a href=/knowledge-base/notes/actor-model/><div class=item-preview><span class=item-preview-title>Actor Model</span><br><span class=item-preview-content>Concept from 1973 by Carl Hewitt:
Actor is the fundamental unit of computation embodying â€¦</span></div></a></li><li><a href=/knowledge-base/notes/akka_router/><div class=item-preview><span class=item-preview-title>Akka Router</span><br><span class=item-preview-content>Intro # In Akka, Router routes messages to destination Akka Actors called routees that â€¦</span></div></a></li></ul></nav></div></aside></main></body></html>