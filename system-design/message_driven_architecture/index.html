<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Asyncronous and non-blocking. The sender does not actively wait for a response.
Advantages:
 Resources are freed immediatly. Reduced contention Messages can be queued for deleivery in case the receiver&rsquo;s is offline. Provides a higher level of reliability.  Disavantages:
 Make transactions more difficult. How to manage long running transactions that span multiple microservices. Holding transactions open for long periods result in slow, brittle systems.  The role of syncronous messags:"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Message Driven Architecture"><meta property="og:description" content="Asyncronous and non-blocking. The sender does not actively wait for a response.
Advantages:
 Resources are freed immediatly. Reduced contention Messages can be queued for deleivery in case the receiver&rsquo;s is offline. Provides a higher level of reliability.  Disavantages:
 Make transactions more difficult. How to manage long running transactions that span multiple microservices. Holding transactions open for long periods result in slow, brittle systems.  The role of syncronous messags:"><meta property="og:type" content="article"><meta property="og:url" content="https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/"><title>Message Driven Architecture | Bruno Henriques</title><link rel=manifest href=/knowledge-base/manifest.json><link rel=icon href=/knowledge-base/favicon.png type=image/x-icon><link rel=stylesheet href=/knowledge-base/book.min.19256db6edae397ffaff8a50dfd331f9f5f916ae4720b444fb87a8d48e9a61f0.css integrity="sha256-GSVttu2uOX/6/4pQ39Mx+fX5Fq5HILRE+4eo1I6aYfA="><script defer src=/knowledge-base/en.search.min.0490e49bbe9ce067b22dd7720d8e50a3a998e3585f89ab97a368bba795094000.js integrity="sha256-BJDkm76c4GeyLddyDY5Qo6mY41hfiauXo2i7p5UJQAA="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/knowledge-base><span>Bruno Henriques</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Concurrency</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/concurrency/actor-model/>Actor Model</a></li></ul></li><li class=book-section-flat><span>Data Processing</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/data-processing/apache-spark/>Apache Spark</a></li><li><a href=https://bphenriques.github.io/knowledge-base/data-processing/states-of-data/>States of Data</a></li></ul></li><li class=book-section-flat><span>Documentation</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/documentation/readme/>readme</a></li></ul></li><li class=book-section-flat><span>JVM</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/jvm/jackson/>Jackson</a></li></ul></li><li class=book-section-flat><span>Learning</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/learning/hands_on_scala_programming/>Hands-on Scala Programming</a></li></ul></li><li class=book-section-flat><span>Messaging Systems</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/messaging-systems/overview/>Messaging Systems Comparison</a></li></ul></li><li class=book-section-flat><span>Monitoring</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/monitoring/bug-management/>Bug Management</a></li></ul></li><li class=book-section-flat><span>Reactive Architecture</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/reactive-architecture/patterns/>Patterns</a></li></ul></li><li class=book-section-flat><span>Security</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/security/jwt/>JWT</a></li></ul></li><li class=book-section-flat><span>System Design</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/>Consistency And Availability</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/distribute_systems/>Distributed Systems</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/>Domain Driven Design</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/ class=active>Message Driven Architecture</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/microservices/>Microservices</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/monolith/>Monolith</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture/>Service Oriented Architecture</a></li></ul></li><li class=book-section-flat><span>Work</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/work/random-memories/>Random Memories</a></li><li><a href=https://bphenriques.github.io/knowledge-base/work/way-of-work/>Way of work</a></li></ul></li><li class=book-section-flat><span>Snippets</span><ul></ul></li><li class=book-section-flat><span>Blog Ideas</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/blog-ideas/using_psql_as_job_queue/>Using PSQL as job queue</a></li></ul></li><li class=book-section-flat><span>Uncategorized</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/akka/>Akka</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/lightbend-academy/>Lightbend Academy</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/org_protocol/>Org-Protocol</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/relevant-xkcds/>Relevant xkcds</a></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/knowledge-base/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Message Driven Architecture</strong>
<label for=toc-control><img src=/knowledge-base/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#sagas>Sagas</a></li><li><a href=#two-general-problem>Two General Problem</a></li><li><a href=#delivery-guarantees>Delivery Guarantees</a></li><li><a href=#messaging-patterns>Messaging Patterns</a><ul><li><a href=#publish-subscribe>Publish Subscribe</a></li><li><a href=#point-to-point>Point to point</a></li><li><a href=#examples>Examples</a></li></ul></li></ul></nav></aside></header><article class=markdown><p>Asyncronous and non-blocking. The sender does not actively wait for a response.</p><p>Advantages:</p><ul><li>Resources are freed immediatly.</li><li>Reduced contention</li><li>Messages can be queued for deleivery in case the receiver&rsquo;s is offline. Provides a higher level of reliability.</li></ul><p>Disavantages:</p><ul><li>Make transactions more difficult.</li><li>How to manage long running transactions that span multiple microservices.</li><li>Holding transactions open for long periods result in slow, brittle systems.</li></ul><p>The role of syncronous messags:</p><ul><li>Can you acknowledge the message but process it asyncronously?</li><li>The need for syncronous messages should be driven by domain requirements rather than technical convenience.</li></ul><h2 id=sagas>Sagas
<a class=anchor href=#sagas>#</a></h2><p>Represent long running transaction. Multiple requests are managed by a Saga.</p><p>Individual requests are run in sequence or in paralel.</p><p>How:</p><ul><li>Each request is paired with a compensating action.</li><li>If any requests fails, compnesation actions are executed for all completed steps.</li><li>Then the saga is completed with a failure.</li><li>If compensation actions fails, then it is retried. This requires idempotency.</li></ul><p>Timeouts in distributed systems:</p><ul><li><p>Eitehr the request failed.</p></li><li><p>Either it was successful but the reply failed.</p></li><li><p>The request is still queued and may success or fail eventually.</p><p>Compensating actions != Rollbacks.</p><p>Rollback: implies the transaction has not completed which removes the evidence of the transaction.
Compensation: Applied on top of a previously completed action. Evidence of the orignal action remains.</p></li></ul><p>Disavantages:</p><ul><li>Coupled to the failures unless we can move regardless of that.</li><li>Saga are often implemented using ackka actors and represented via Finite State Machine.</li></ul><h2 id=two-general-problem>Two General Problem
<a class=anchor href=#two-general-problem>#</a></h2><p>Illustrate the impossibility of reaching a concensus over an unreliable communication channel.</p><h2 id=delivery-guarantees>Delivery Guarantees
<a class=anchor href=#delivery-guarantees>#</a></h2><ul><li>Exactly Once: Is not possible in the event of a network partition, or lost message. We never guarantee that the message was in-fact sent. Failure requires resending the message which creates <em>potential</em> duplicates. Reuqires storage on both ends: unreliable network (as always); timeouts.</li><li>At most once - If a failure occur, no retries are done which means no duplications but there may be losses. Requires no storage of messages.</li><li>At least once - Require a acknoledge and teh sender needs to store state to track whether the messsage was acknowledge. It ahs to be stored in a durable data store.</li></ul><p>Exactly once can be simulated using at least once and idempotency.</p><p>Akka: at most once by default. Akka persistence has option to have at least once.</p><h2 id=messaging-patterns>Messaging Patterns
<a class=anchor href=#messaging-patterns>#</a></h2><h3 id=publish-subscribe>Publish Subscribe
<a class=anchor href=#publish-subscribe>#</a></h3><p>Decoupled. The only coupling is on the message format and possibily the location (e.g., url, exchange on the message broker). Complexity is hard to see as we do not know where the message comes from.</p><h3 id=point-to-point>Point to point
<a class=anchor href=#point-to-point>#</a></h3><p>Dependencies more clear but coupling is higher. COmplexity is directly observable.</p><h3 id=examples>Examples
<a class=anchor href=#examples>#</a></h3><p>Kafaka, RabbitMQ. Kafka allows point to point and pub/sub and we can even acknowledge once we finish processing.</p><p>Akka: Typically point to point messaging;Persistence Query: Pub/sub
Lagom: Point to point communication between services. Messages broker API allow for pub/sub.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div><a class="flex align-center" href=https://github.com/bphenriques/knowledge-base/edit/master/org/system-design/message_driven_architecture.org target=_blank rel=noopener><img src=/knowledge-base/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#sagas>Sagas</a></li><li><a href=#two-general-problem>Two General Problem</a></li><li><a href=#delivery-guarantees>Delivery Guarantees</a></li><li><a href=#messaging-patterns>Messaging Patterns</a><ul><li><a href=#publish-subscribe>Publish Subscribe</a></li><li><a href=#point-to-point>Point to point</a></li><li><a href=#examples>Examples</a></li></ul></li></ul></nav></aside></main></body></html>