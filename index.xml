<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Bruno Henriques</title><link>https://bphenriques.github.io/knowledge-base/</link><description>Recent content in Introduction on Bruno Henriques</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://bphenriques.github.io/knowledge-base/index.xml" rel="self" type="application/rss+xml"/><item><title>Actor Model</title><link>https://bphenriques.github.io/knowledge-base/concurrency/actor-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/concurrency/actor-model/</guid><description>In the context of Reactive Systems, Actor model is a reactive tool, a paradigm that:
Message driven - All communication between actors is done with async non-blocking messages. Abstractions provide elasticity and resiliency. Akka uses the actor model - https://doc.akka.io/docs/akka/current/typed/guide/actors-intro.html?language=scala
Fundamental # All computation occurs inside of the actor. Each actor has an address. Actors only communicate through asyncronous messages. The message driven system provides location transparency, i.</description></item><item><title>Apache Spark</title><link>https://bphenriques.github.io/knowledge-base/data-processing/apache-spark/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/data-processing/apache-spark/</guid><description>Glossary # RDD - Resilient Distributed Datasets</description></item><item><title>Bug Management</title><link>https://bphenriques.github.io/knowledge-base/monitoring/bug-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/monitoring/bug-management/</guid><description>Some personal notes on simplifying the process so that one can focus on getting back to the other tasks at hand.
On Reporting Bugs # Focus on the impact for the client. You do not need to debug right away. You do not need to establish the timeline - The report can solely include the context. The person assigned to the issue will pick on the context provided in the ticket and explore.</description></item><item><title>Command Sourcing</title><link>https://bphenriques.github.io/knowledge-base/system-design/command_sourcing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/command_sourcing/</guid><description>Command Sourcing # Similar to Event Sourcing but persists commands as opposed to events so:
Issue command
Persist command
Run asyncronous the command
They should be idempotent as they run multiple times (e.g., failures).
Must be validated so that they do not become stuck in the queue forever.
Bad: The sender might not be notified if the command fails due to the decouple nature.</description></item><item><title>Consistency And Availability</title><link>https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/</guid><description>Scalability # It can meets increases in demand while remaining responsive.
This is different from performance. Performance optimizes response time (latency) while scalability optimizes ability to handle load. Requests per second actually measures both but we do not know which aspect was improved.
Note Scalability is not the number of requests qwe can handle a in a given period of time (req/sec) but he number of requests itself (load).</description></item><item><title>CQRS/ES</title><link>https://bphenriques.github.io/knowledge-base/system-design/cqrs_es/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/cqrs_es/</guid><description>CQRS/ES stands for Command Query Responsibility Segregation and Event Sourcing.
Use Cases:
Auditing (e.g., banking, accounting) High Scalability High Resiliency There are trade-offs, what are they?
CQRS # State Based Persistence. Every time an update is applied to the database it obliterates previous state.
Can&amp;rsquo;t fix bad state due to previous error. Can&amp;rsquo;t retroactively apply new domain insights (because we do not have the previous states). This solely tells where we are but not how we got there: must be allied with Event Sourcing.</description></item><item><title>Domain Driven Design</title><link>https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/</guid><description>Referred in
Microservices See raw in Lightbend Academy
Useful for modelling use-cases before attempting to implement it whether in Software or mere Diagrams.
Subject-Verb-Object notation # Allows having a consistent way to phrase activies our events in the domain.
Example: Host checks current reservation.
Subject: Host Verb: Checks Object: Reservation Note that &amp;ldquo;current&amp;rdquo; can be seen as a modifier.
Sometimes there may be multiple objects.</description></item><item><title>Event Sourcing</title><link>https://bphenriques.github.io/knowledge-base/system-design/event_sourcing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/event_sourcing/</guid><description>Referred in
CQRS/ES Command Sourcing Event Sourcing (ES) # In addition to persisting state, one persists audit logs. This captures the history. It is better to have this in a database as it provides transactionality.
Wary when persisting in the database and in-memory:
Two potential source of truth if they disagree. Both must be updated in transactionality. A bug in the code may lead to both of them becoming out-of-sync.</description></item><item><title>Hands-on Scala Programming</title><link>https://bphenriques.github.io/knowledge-base/learning/hands_on_scala_programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/learning/hands_on_scala_programming/</guid><description>Follows my notes on the Haoyi Li.&amp;rsquo;s book: &amp;ldquo;Hands-on Scala Programming&amp;rdquo;.
As an experiment, I coding directly in the org-mode file using Babel to execute the Scala blocks:
TODO Some introduction # Point to dotfiles Point to the Babel package Notes # Lack of auto-complete when writing here. Compilation errors are hard to track. Workaround is to open a separate buffer with the ammonite REPL console.</description></item><item><title>JWT</title><link>https://bphenriques.github.io/knowledge-base/security/jwt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/security/jwt/</guid><description>What it is # JSON Web Tokens
What it solves # What it does not solve #</description></item><item><title>Message Driven Architecture</title><link>https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/</guid><description>Asyncronous and non-blocking. The sender does not actively wait for a response.
Advantages:
Resources are freed immediatly. Reduced contention Messages can be queued for deleivery in case the receiver&amp;rsquo;s is offline. Provides a higher level of reliability. Disavantages:
Make transactions more difficult. How to manage long running transactions that span multiple microservices. Holding transactions open for long periods result in slow, brittle systems. The role of syncronous messags:</description></item><item><title>Messaging Systems Comparison</title><link>https://bphenriques.github.io/knowledge-base/messaging-systems/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/messaging-systems/overview/</guid><description>Kafka # Event Streaming, persistent.
RabbitMQ # Low latency.
Pulsar # Made by Apache
TODO # Read this comparison: https://www.confluent.io/kafka-vs-pulsar/#:~:text=In%20reality%2C%20Kafka%2C%20RabbitMQ%2C,Pulsar%20sits%20somewhere%20in%20between.</description></item><item><title>Microservices</title><link>https://bphenriques.github.io/knowledge-base/system-design/microservices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/microservices/</guid><description>Referred in
Service Oriented Architecture Subset of Service Oriented Architecture where each service is deployed separately:
Microservices can be physically separated and independently deployed. Each have its own data store. Independent and self governing. Communication is syncronous or asyncronous (e.g., through message brokers). Loose coupling between components (more or less by experience but that is design flaw likely :thinking:). Shorter development and release cycles. Each scale independently (either through physical or virtual machines).</description></item><item><title>Monolith</title><link>https://bphenriques.github.io/knowledge-base/system-design/monolith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/monolith/</guid><description>Referred in
Domain Driven Design Service Oriented Architecture Some notes taken during the lightbend course on Reactive Microservices. Some of these ideas are familiar as they are intuitive.
Deployed as a single unit. No Clear Isolation. Complex Depedencies -&amp;gt; Hard to understand and modify. Communication using syncronous calls. Hmmm, I disagree and I think that it depends.. E.g., Spring allows services call another with asyncronous methods within the same monolith.</description></item><item><title>Random Memories</title><link>https://bphenriques.github.io/knowledge-base/work/random-memories/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/work/random-memories/</guid><description>Curious ideas/sentences and what not from now and then. Some things are pretty obvious but worthwhile remembering (:
Failure in systems are inevitable. We have to accept and build a system that isolates such failures in a way that becomes unnoticible to the end-user. User does not care whether the software was faulty due to a third-party vender or not. When we build software we have to consider third-party vendors and if we don&amp;rsquo;t properly isolate ourselves from their faulty behavior, users are going to pay for that.</description></item><item><title>Reactive Systems</title><link>https://bphenriques.github.io/knowledge-base/system-design/reactive_systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/reactive_systems/</guid><description>Goal # Provide an experience that is responsive under all conditions.
This requires:
Ability to scale from 10 users to million of users. Consume solely the resources required to support the current work-load. Reactor Principles # Responsive # Always respond in a timely manner.
Resiliency # Isolate failures on single components - Similar to how a boat is designed.
Elastic # Keep responsive specially when the system load changes which provides a more efficient usage of resources.</description></item><item><title>Readme</title><link>https://bphenriques.github.io/knowledge-base/documentation/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/documentation/readme/</guid><description>Several examples # https://github.com/matiassingers/awesome-readme Like minimalistic versions as they require less maintenance (hmmm :thinking-face:)</description></item><item><title>Service Oriented Architecture</title><link>https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture/</guid><description> Referred in
Monolith Microservices As opposed to Monolith, services do not share a database and all access must be done through a API exposed by the service. They may be in the same process (Monolith) or may be separated (Microservices). This reduces coupling.
E.g.:
Orders -&amp;gt; RDBMS Customers -&amp;gt; No SQL Reservations -&amp;gt; Web Service Menu -&amp;gt; RDBMS</description></item><item><title>States of Data</title><link>https://bphenriques.github.io/knowledge-base/data-processing/states-of-data/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/data-processing/states-of-data/</guid><description>States of data:
At Rest: Data that is not consumed at the time is injested. It is stored and then consumed later in a batch process. In Transit: Data that is travelling between point A and point B. In Use: Data that is opened for treatment Encountered several concerns regarding how such data must be handled. Follows a link to be reviewed later:three-states-of-data</description></item><item><title>Way of work</title><link>https://bphenriques.github.io/knowledge-base/work/way-of-work/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/work/way-of-work/</guid><description>It&amp;rsquo;s not about being right nor prove others wrong # Corollary 1: if it&amp;rsquo;s wrong but it works, then it&amp;rsquo;s not wrong. Corollary 2: if you&amp;rsquo;re right but it doesn&amp;rsquo;t change the outcome, then it doesn&amp;rsquo;t matter. Corollary 3: if you&amp;rsquo;re right, but it doesn&amp;rsquo;t work, then you&amp;rsquo;re wrong. Corollary 4: if you prove someone else wrong, but their answer works and yours doesn&amp;rsquo;t, then they&amp;rsquo;re right and you&amp;rsquo;re wrong.</description></item><item><title>Emacs</title><link>https://bphenriques.github.io/knowledge-base/snippets/emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/snippets/emacs/</guid><description>TODO Personalize deft for other directories # For now I do not need.
;;function to run deft in specified directory (defun bjm-deft (dir) &amp;#34;Run deft in directory DIR&amp;#34; (setq deft-directory dir) (switch-to-buffer &amp;#34;*Deft*&amp;#34;) (kill-this-buffer) (deft) )</description></item><item><title>Jackson</title><link>https://bphenriques.github.io/knowledge-base/snippets/jackson/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/snippets/jackson/</guid><description>Sane Settings # After working a while with this I want to register these sane defaults:
configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true) configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false) FAIL_ON_NULL_FOR_PRIMITIVES # Setting FAIL_ON_NULL_FOR_PRIMITIVES forces clients to explicitely provide all values including primitives. Consider the following POJO:
data class Foo(bar: Boolean) Without the setting, a payload such as { } would render ~Foo(bar=false)~ despite the lack of default value. Given this, to guarantee consistency between the source-code and the external contract, I advise enabling this.</description></item><item><title>Akka</title><link>https://bphenriques.github.io/knowledge-base/uncategorized/akka/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/uncategorized/akka/</guid><description>Akka Distributed Data # CRDTs in distributed data are stored in memory. Can be copied to disk to speed up recovery if a replica fails.
Best used for small data sets with infrequent updates that require high availability.
Limitations CRDT: Do not work with every data type that require a merge function. Some data types are too complex to merge and require the use of tombstone:
A marker that shows something was deleted.</description></item><item><title>Lightbend Academy</title><link>https://bphenriques.github.io/knowledge-base/uncategorized/lightbend-academy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/uncategorized/lightbend-academy/</guid><description>Referred in
Domain Driven Design Reactive Programming vs Reactive Systems # They are not the same.
Reactive systems apply the reactive principles on a architectural level.
Reactive Programming can be (and often is) used to build reactive systems but that does not mean that it is a reactive system.
In order to have a reactive architecture, it means that the reactive systems needs to be separated thorugh asyncronous boundaries.</description></item><item><title>Org-Protocol</title><link>https://bphenriques.github.io/knowledge-base/uncategorized/org_protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/uncategorized/org_protocol/</guid><description>Useful guide: https://github.com/xuchunyang/setup-org-protocol-on-mac</description></item><item><title>Relevant xkcds</title><link>https://bphenriques.github.io/knowledge-base/uncategorized/relevant-xkcds/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/uncategorized/relevant-xkcds/</guid><description>On Standards # https://xkcd.com/927/</description></item></channel></rss>