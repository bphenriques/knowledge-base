<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Bruno Henriques's Digital Garden ðŸŒ±</title><link>https://bphenriques.github.io/knowledge-base/notes/</link><description>Recent content in Notes on Bruno Henriques's Digital Garden ðŸŒ±</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://bphenriques.github.io/knowledge-base/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Actor Model</title><link>https://bphenriques.github.io/knowledge-base/notes/actor-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/actor-model/</guid><description>Concept from 1973 by Carl Hewitt:
Actor is the fundamental unit of computation embodying processing, storage, and communication.
Fundamentals # All computation occurs inside of the actor. Each actor has an address. Actors may create new actors, send messages to them and changing their own behavior to handle new messages (e.g., change the state). An actor does not exist isolated, it works in tandem with others and are arranged in hierarquy:</description></item><item><title>Akka</title><link>https://bphenriques.github.io/knowledge-base/notes/akka/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka/</guid><description>Akka # Toolkit and runtime for building highly concurrent, distributed and fault tolerant message-driven application in the JVM. It can be used to build Reactive Systems .
Proposes unified programming model for:
Simpler concurrency: single threaded illusion as each actor processes a message at a time (no need to locks or synchronization strategies). Simpler distribution: is distributed by default (see more on Akka Cluster ). Simpler fault tolerance: Decouples communication from failure handling.</description></item><item><title>Akka Actors</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_actors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_actors/</guid><description>Handling Messages Asyncronously # Blocking threads inside the actors creates contention therefore the handling of the messages must happen in a async fashion, including any DB writes and DB reads when starting the actor. For example, using interfaces such as Future[T]. However this may lead to concurrency within the actor itself removing the ilusion of a single thread. This means that messages must be stash until other operations complete.</description></item><item><title>Akka Cluster</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_cluster/</guid><description>Akka Cluster # Scenario: Make actors communicate across the network.
Allows actors to communicate across the network, greatly simplifying the process. Each node represents an actor system and they all share the same name.
Akka Cluster Aware Routers # Scenario: High workload.
Scalling vertically has limits. Introducing Akka Cluster Aware Routers, that allows scalling the system horizontally. I.e., large tasks are broken on smaller tasks that are routed to an especific node of our cluster.</description></item><item><title>Akka Dispatcher</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_dispatcher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_dispatcher/</guid><description>The engine of Akka as it decides when a actor should process messsages and when it must yield the thread for others. It means that dispatchers are in control of the thread time and of the threads themselves.
Dispatcher (default): Event-driven dispatcher, sharing threads from thread pool. PinnedDispatcher: Dedicated thread per actor. CallingThreadDispatcher: Just for testing. The best tips are:
Adjust throughput to deliver more messages to the actors before yielding.</description></item><item><title>Akka Router</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_router/</guid><description>Intro # In Akka, Router routes messages to destination Akka Actors called routees that can process messages in parallel to improve throughput. The way routing is done may be configured to fit the use-case.
Routing Strategies # Determines how router routes to its routees.
RandomRoutingLogic: Pure random and fast. May be unbalanced. RoundRobinRoutingLogic: Take turns. Is more fair and distributed. But depending on the messages, some actors may have more work than others.</description></item><item><title>Akka Sharding</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_sharding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_sharding/</guid><description>Akka Cluster Sharding # Distribute actors across a cluster:
Entities: The main unit (e.g., UserId) Shards: Holds entities (e.g., each shard holds 10 UserIds). Shard Region: Holds Shards. Shard Coordinator: Manages shards. Entity # The main unit is: Entity identified by the EntityId which in essence represents the aggregate root&amp;rsquo;s identifier of a concept of our domain (e.g., UserId) and is unique within the cluster. This leads to Strong Consistency given that Akka provides the single thread illusion.</description></item><item><title>Akka Streams</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_streams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_streams/</guid><description>Actor Streams leverage the actor system to consume streams of data. In fact, each element of a stream is a Message within the Actor System
Here, data flows through a chain of processing stages:
Sources: The &amp;ldquo;source&amp;rdquo; (e.g., CSV file). Sinks: The &amp;ldquo;destination&amp;rdquo; (e.g., a file). Flows: Transformations made to the data within the Stream (e.g., total number of lines). Runnable Graphs: A stream where all inputs and outputs are connected.</description></item><item><title>Akka Testing</title><link>https://bphenriques.github.io/knowledge-base/notes/akka_testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/akka_testing/</guid><description>How to test actors in Akka.
Test Actor Ref # Synchronous and ideal for white-box testing as we can change the internal state.
Test Probes # Black-box testing and then verify if specific messages were sent (and other assertions).
(black box is always better :) )</description></item><item><title>Amdah's Law</title><link>https://bphenriques.github.io/knowledge-base/notes/amdah_s_law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/amdah_s_law/</guid><description>In short, contention limits paralelization.
Defines the maximum improvement gaines by parallel procesing. Improvements from paralelization are limited to the code that can be paralelized. Contention limits such paralism reducing the advantages of the improvements. Does not matter as long as the contention exist.</description></item><item><title>BASE Transaction</title><link>https://bphenriques.github.io/knowledge-base/notes/base_transaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/base_transaction/</guid><description>Sometimes ACID transactions are not possible in some cases, e.g., microservices. As alternative, we use BASE transactions:
Basically Available Soft State Eventual Consistency The difference from ACID transactions it that they cannot be rolledback easily. To rollback, a compensating action is needed to revert to the original state. Saga manages these kind of transactions and are often used to manage different aggregate roots (see Domain Driven Design ).</description></item><item><title>Bug Management</title><link>https://bphenriques.github.io/knowledge-base/notes/bug-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/bug-management/</guid><description>Some personal notes on simplifying the process so that one can focus on getting back to the other tasks at hand.
On Reporting Bugs # Focus on the impact for the client. You do not need to debug right away. You do not need to establish the timeline - The report can solely include the context. The person assigned to the issue will pick on the context provided in the ticket and explore.</description></item><item><title>Cloud Testing</title><link>https://bphenriques.github.io/knowledge-base/notes/cloud_testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/cloud_testing/</guid><description>In order to test AWS services locally, we can use https://docs.localstack.cloud/ which runs locally and offline.</description></item><item><title>Command Query Responsibility Segregation (CQRS)</title><link>https://bphenriques.github.io/knowledge-base/notes/command_query_responsibility_segregation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/command_query_responsibility_segregation/</guid><description>Command Query Responsibility Segregation (CQRS) is a architectural pattern that aims to split applications between two models: Command Model (writes) and Query Model (reads). Some use cases:
Auditing (e.g., banking, accounting) High Scalability High Resiliency This separation allows both concerns to evolve separately depending on the requirements. For example, some Aggregate Roots are a better fit for write models but do not fit other read models.
This pattern is often combined with Event Sourcing (ES) .</description></item><item><title>Command Sourcing</title><link>https://bphenriques.github.io/knowledge-base/notes/command_sourcing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/command_sourcing/</guid><description>Command Sourcing # Similar to Event Sourcing (ES) but persists commands as opposed to events so:
Issue command
Persist command
Run asyncronous the command
They should be idempotent as they run multiple times (e.g., failures).
Must be validated so that they do not become stuck in the queue forever.
Bad: The sender might not be notified if the command fails due to the decouple nature.</description></item><item><title>Consistency And Availability</title><link>https://bphenriques.github.io/knowledge-base/notes/consistency_and_availability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/consistency_and_availability/</guid><description>Scalability # It can meets increases in demand while remaining responsive.
This is different from performance. Performance optimizes response time (latency) while scalability optimizes ability to handle load. Requests per second actually measures both but we do not know which aspect was improved.
Note Scalability is not the number of requests qwe can handle a in a given period of time (req/sec) but he number of requests itself (load).</description></item><item><title>Digital Garden</title><link>https://bphenriques.github.io/knowledge-base/notes/digital_garden/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/digital_garden/</guid><description>Digital gardening is a different take to blogging as it shifts the focus of publishing content to a public to the writing.
Like gardening, digital gardens start with raw notes and, as we tend to it, connections will start to emerge. But it is personal and informal. There is no pressure on having complete thoughts. You can always circle back to the notes you made in the past and refine them.</description></item><item><title>Domain Driven Design</title><link>https://bphenriques.github.io/knowledge-base/notes/domain_driven_design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/domain_driven_design/</guid><description>Approach on Software Development focused on the design of a shared Model understood by domain experts and by who implements it. Being a model, it means that it can be implemented in different ways, from diagrams to software.
Concepts # Context: The setting a word appers determines its meaning. Domain: Sphere of knowledge, influence or activity (aka area). Model: System of abstractions that describes a part of the domain.</description></item><item><title>Emacs</title><link>https://bphenriques.github.io/knowledge-base/notes/emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/emacs/</guid><description>Org-Mode # Org-protocol is cool and opens possibilities (like there weren&amp;rsquo;t enoguh :overwhelmed:):
https://orgmode.org/worg/org-contrib/org-protocol.html#orgheadline8 Configuring # Literate config is a thing but unfortunately as far as I researched it has to be contained in a single file. I rather have separate files per use-case.
Cool reference links:
https://tecosaur.github.io/emacs-config/config.html http://doc.norang.ca/org-mode.html:w https://github.com/jethrokuan/dots/blob/0064ea2aab667f115a14ce48292731db46302c53/.doom.d/config.el#L495 https://github.com/nmartin84/.doom.d#orgb81fe7f https://github.com/howardabrams/dot-files/blob/master/emacs-org.org</description></item><item><title>Event Sourcing (ES)</title><link>https://bphenriques.github.io/knowledge-base/notes/event_sourcing_es_es/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/event_sourcing_es_es/</guid><description>Representing the application&amp;rsquo;s state through the history of events that have happened in the past. Use cases:
Audit Logs: Build tailored reports from the event stream. Analytics: Extract behavior from the event stream. Temporal Reports: Build the timeline that led to a certain state. This is the opposite of regular applications where the final state is stored. In Event Sourced applications, the final state is called Materialized State. Whenever we need to obtain the current state we replay the logs until we reach the current state without replaying the side-effects.</description></item><item><title>Git</title><link>https://bphenriques.github.io/knowledge-base/notes/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/git/</guid><description>Get Previous Tag # $ git for-each-ref --sort=creatordate --format '%(refname)' refs/tags | sed 's#^refs/tags/##' | tail -n 2 | head -n 1</description></item><item><title>Gossip Protocol</title><link>https://bphenriques.github.io/knowledge-base/notes/gossip_protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/gossip_protocol/</guid><description>Some of these text may be interwined with specifities of the Gossip Protocol within Akka Cluster .
Context: TODO
At a regular interval, each member sends their view of the cluster state to a random node, including:
The status of each member If each member has seen this version of the cluster state. Eventually consistent as after some time (aka convergence), all nodes will share the same state. Each node decides if it has reached convergence.</description></item><item><title>GPG</title><link>https://bphenriques.github.io/knowledge-base/notes/gpg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/gpg/</guid><description>Automatically export public key to a server:
$ gpg --keyserver pgp.mit.edu --send-keys &amp;lt;KEY&amp;gt;</description></item><item><title>Gunther's Universal Scalability Law</title><link>https://bphenriques.github.io/knowledge-base/notes/gunther_s_universal_scalability_law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/gunther_s_universal_scalability_law/</guid><description>Increasing concurrency can cause negative resutrns due to contention and coherency delay.
Picks from Amdah&amp;rsquo;s Law . In addition to contention, it accounts for coeherency delay.
As the system scales up, the cost to coordinate between nodes exceeds any benefits.</description></item><item><title>Hands-on Scala Programming</title><link>https://bphenriques.github.io/knowledge-base/notes/hands_on_scala_programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/hands_on_scala_programming/</guid><description>Follows my notes on the Haoyi Li.&amp;rsquo;s book: &amp;ldquo;Hands-on Scala Programming&amp;rdquo; (https://www.handsonscala.com/ ).
As an experiment, I coding directly in the org-mode file using Babel to execute the Scala blocks:
TODO Some introduction # Point to dotfiles Point to the Babel package Notes # Lack of auto-complete when writing here. Compilation errors are hard to track. Workaround is to open a separate buffer with the ammonite REPL console.</description></item><item><title>Heartbeat</title><link>https://bphenriques.github.io/knowledge-base/notes/heartbeat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/heartbeat/</guid><description>In order to detect failures, systems communicate with one another to verify communication. If the communication is deemed broken, then the system may be considered as Unreachable depending on he heartbeat history and how the Failure Detection is configured. I.e., a single heartbeat does not mean that the member is Unreachable.</description></item><item><title>Interview Questions</title><link>https://bphenriques.github.io/knowledge-base/notes/interview_questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/interview_questions/</guid><description>Behaviour Questions # Follows a snippet made by Michael Kusters (link):
Interviewer: &amp;quot;Can you give us an example of a situation where you had to resolve a conflict?&amp;quot; Candidate: &amp;quot;What does your management do to create a friendly environment where conflicts are easy to address and resolve?&amp;quot; Interviewer: &amp;quot;Could you tell us about a situation where you had to deal with a difficult coworker?&amp;quot; Candidate: &amp;quot;Do I have to worry about difficult coworkers here?</description></item><item><title>Jackson</title><link>https://bphenriques.github.io/knowledge-base/notes/jackson/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/jackson/</guid><description>Jackson is a library to serialize and deserialize JSON in the JVM world.
Sane Settings # After working a while with this I want to register these sane defaults:
configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true) configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false) FAIL_ON_NULL_FOR_PRIMITIVES # Setting FAIL_ON_NULL_FOR_PRIMITIVES forces clients to explicitely provide all values including primitives. Consider the following POJO:
data class Foo(bar: Boolean) Without the setting, a payload such as { } would render ~Foo(bar=false)~ despite the lack of default value.</description></item><item><title>Json Processing Cookbook</title><link>https://bphenriques.github.io/knowledge-base/notes/json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/json/</guid><description>Flatten Json # jq -r &amp;#39;. | tostream | select(length==2) | (.[0] | join(&amp;#34;.&amp;#34;)) as $k | .[1] as $v | &amp;#34;\&amp;#34;\($k)\&amp;#34; = \&amp;#34;\($v)\&amp;#34;;&amp;#34;&amp;#39;</description></item><item><title>Kotlin</title><link>https://bphenriques.github.io/knowledge-base/notes/kotlin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/kotlin/</guid><description>Asserting asynchronous task # Sometimes CountdownLatch is not feasible as it is not possible to inject it. The alternative pool until the system reaches the desired state. This approach is not ideal as it may block the system longer than strictly required.
As mid-term solution, in any-case opt for CountdownLatch if possible.
fun assertWaitFor(timeoutMs: Long = 5000, intervalMs: Long = 250, fn: () -&amp;gt; Unit) { val start = Instant.</description></item><item><title>Message Driven Architecture</title><link>https://bphenriques.github.io/knowledge-base/notes/message_driven_architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/message_driven_architecture/</guid><description>Asyncronous and non-blocking. The sender does not actively wait for a response.
Advantages:
Resources are freed immediatly. Reduced contention Messages can be queued for deleivery in case the receiver&amp;rsquo;s is offline. Provides a higher level of reliability. Disavantages:
Make transactions more difficult. How to manage long running transactions that span multiple microservices. Holding transactions open for long periods result in slow, brittle systems. The role of syncronous messags:</description></item><item><title>Microservices</title><link>https://bphenriques.github.io/knowledge-base/notes/microservices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/microservices/</guid><description>Subset of Service Oriented Architecture (SOA) where each service is deployed separately:
Microservices can be physically separated and independently deployed. Each have its own data store. Independent and self governing. Communication is syncronous or asyncronous (e.g., through messaging systems). Loose coupling between components (more or less by experience but that is design flaw likely :thinking:). Shorter development and release cycles. Each scale independently (either through physical or virtual machines). Advantages # Deployed/Scaled as needed.</description></item><item><title>Monolith</title><link>https://bphenriques.github.io/knowledge-base/notes/monolith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/monolith/</guid><description>Characteristics # Deployed as a single unit. No Clear Isolation. Complex Dependencies which in turn makes it hard to understand and modify. Big Bang Style Releases Long Cycle Times Careful releases Scalation is done with multiple copies and uses the database as consistency between them. Advantages: # Easy Cross Module Refactor Easier to maitain consistency Single Deploy Process Single thing to monitor Simple Scalability Model Disadvantages: # Limited by the maximum size of a single physical machine.</description></item><item><title>Nix</title><link>https://bphenriques.github.io/knowledge-base/notes/nix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/nix/</guid><description>Nix is a declarative language aiming produce reproducible systems. In can be used to produce dotfiles.
Follows three tools:
Home Manager : Manages user&amp;rsquo;s home. It can&amp;rsquo;t be used to install fonts for example. Nix Darwin : Manages macOS systems. The goal is to compose these tools to produce a reproducible generation of one&amp;rsquo;s environment. To aid this, Nix Flakes introduces another layer on top that aims to pin the versions the dependencies through a flake.</description></item><item><title>PostgreSQL</title><link>https://bphenriques.github.io/knowledge-base/notes/postgresql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/postgresql/</guid><description>Relational database.
One can run in a docker-compose environment like this:
version: &amp;#39;3.8&amp;#39; services: postgres: image: postgres:13.3 # Version must be consistent with infrastructure environment: - &amp;#34;PGUSER=test&amp;#34; - &amp;#34;POSTGRES_USER=test&amp;#34; - &amp;#34;POSTGRES_PASSWORD=test&amp;#34; - &amp;#34;POSTGRES_DB=test&amp;#34; ports: - &amp;#34;5432:5432&amp;#34; healthcheck: test: [&amp;#34;CMD-SHELL&amp;#34;, &amp;#34;pg_isready&amp;#34;] interval: 5s timeout: 5s retries: 5</description></item><item><title>Reactive Streams</title><link>https://bphenriques.github.io/knowledge-base/notes/reactive_streams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/reactive_streams/</guid><description>Components of a Reactive Stream:
Publisher: Publishes data to stream Subscriber: Consumes data from the stream. Processor: Acts as both a publisher and a subscriber, obeying the contract for each. Subscription: Connects a subscriber to a publisher to initiate a message flow. Akka Streams is built on these concepts but provides a different API (albeit is possible to bridge).</description></item><item><title>Reactive Systems</title><link>https://bphenriques.github.io/knowledge-base/notes/reactive_systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/reactive_systems/</guid><description>Goal # Provide an experience that is responsive under all conditions. Note that reactive programming is not the same as reactive systems.
This requires:
Ability to scale from 10 users to million of users. Consume solely the resources required to support the current work-load. Reactive Principles # Systems that apply the following principles are considered reactive systems (see more here ).
Responsive # Always respond in a timely manner.</description></item><item><title>Referential Transparency</title><link>https://bphenriques.github.io/knowledge-base/notes/referential_transparency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/referential_transparency/</guid><description>Referential transparency: replacing an expression by its bound value doesn&amp;rsquo;t alter the behaviour of your program. This gives huge benefits, which I&amp;rsquo;ll talk about later.
References # https://www.reddit.com/r/scala/comments/8ygjcq/can_someone_explain_to_me_the_benefits_of_io/ https://www.youtube.com/watch?v=x3GLwl1FxcA&amp;t=189s</description></item><item><title>Resources to (re)-read</title><link>https://bphenriques.github.io/knowledge-base/notes/web-stack-enties/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/web-stack-enties/</guid><description>Things I Wished More Developers Knew About Databases # Source: https://rakyll.medium.com/things-i-wished-more-developers-knew-about-databases-2d0178464f78 How To Drive Change as a Software Engineer # Source: https://www.lihaoyi.com/post/HowToDriveChangeasaSoftwareEngineer.html The Dark Side of Events - YouTube # Source: https://www.youtube.com/watch?v=URYPpY3SgS8&amp;feature=youtu.be&amp;t=1884 Ask HN: How to Take Good Notes? | Hacker News # Source: https://news.ycombinator.com/item?id=22473209 Unlearning toxic behaviors in a code review culture | by Sandya Sankarram | Medium # Source: https://medium.com/@sandya.sankarram/unlearning-toxic-behaviors-in-a-code-review-culture-b7c295452a3c Nicolas Mattia â€“ Nix: A Reproducible Setup for Linux and macOS # Source: https://www.</description></item><item><title>Scala Experiments</title><link>https://bphenriques.github.io/knowledge-base/notes/scala_experiments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/scala_experiments/</guid><description>Implementing Tree # sealed class Tree[T] { def stream(): LazyList[T] = this match { case Leaf(value) =&amp;gt; LazyList(value) case Branch(left, right) =&amp;gt; left.stream() #::: right.stream() } } case class Branch[T](left: Tree[T], right: Tree[T]) extends Tree[T] case class Leaf[T](value: T) extends Tree[T] val tree = Branch( Leaf(1), Branch( Leaf(2), Leaf(3) ) ) val nextInOrder = tree.stream().dropWhile(_ != 2).drop(1).headOption println(nextInOrder)</description></item><item><title>Sharding or Partitioning</title><link>https://bphenriques.github.io/knowledge-base/notes/sharding_or_partitioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/sharding_or_partitioning/</guid><description>Technique used by some data stores to reduce contention without sacrificing consistency.
Records are distributed across nodes using a Shard Key or a Partition Key that will be used by the Database Router that redirects requests to the correct shard/partition.
Benefits:
Contention is isolated to a shard/partition. Given that each shard stores a part of the dataset, it is only handling a small part of the overall load. Improves elasticity.</description></item><item><title>SLI/SLO</title><link>https://bphenriques.github.io/knowledge-base/notes/sli_slo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/sli_slo/</guid><description>Service Level Indicator (SLI): Performance indicator measured as a ratio of two numbers. Service Level Objective (SLO): Defines a target SLI as measurment of the systems&amp;rsquo;s reliability. Service Level Agreement (SLA): Business contract regarding the expected SLO. It is far productive measuring them as use-histories as it defines the critical paths.</description></item><item><title>Stateless</title><link>https://bphenriques.github.io/knowledge-base/notes/stateless/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/stateless/</guid><description>Stateless systems means that:
The system contains all the required information to complete requests. Requests can be processed on any instance of of the application. Note that, some &amp;ldquo;stateless&amp;rdquo; systems can&amp;rsquo;t be considered as such as the state is contained in a database.</description></item><item><title>States of Data</title><link>https://bphenriques.github.io/knowledge-base/notes/states-of-data/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/states-of-data/</guid><description>States of data:
At Rest: Data that is not consumed at the time is ingested. It is stored and then consumed later in a batch process. In Transit: Data that is travelling between point A and point B. In Use: Data that is opened for treatment Reference: three-states-of-data</description></item><item><title>Thinking Tools</title><link>https://bphenriques.github.io/knowledge-base/notes/thinking_tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/thinking_tools/</guid><description>Follows some interesting resources:
https://untools.co/</description></item><item><title>Way of work</title><link>https://bphenriques.github.io/knowledge-base/notes/way-of-work/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/way-of-work/</guid><description>It&amp;rsquo;s not about being right nor prove others wrong # Corollary 1: if it&amp;rsquo;s wrong but it works, then it&amp;rsquo;s not wrong. Corollary 2: if you&amp;rsquo;re right but it doesn&amp;rsquo;t change the outcome, then it doesn&amp;rsquo;t matter. Corollary 3: if you&amp;rsquo;re right, but it doesn&amp;rsquo;t work, then you&amp;rsquo;re wrong. Corollary 4: if you prove someone else wrong, but their answer works and yours doesn&amp;rsquo;t, then they&amp;rsquo;re right and you&amp;rsquo;re wrong.</description></item></channel></rss>