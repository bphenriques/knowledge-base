<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Command Query Responsibility Segregation (CQRS) is a architectural pattern that aims to split applications between two models: Command Model (writes) and Query Model (reads). Some use cases:
 Auditing (e.g., banking, accounting) High Scalability High Resiliency  This separation allows both concerns to evolve separately depending on the requirements. For example, some Aggregate Roots are a better fit for write models but do not fit other read models.
This pattern is often combined with Event Sourcing (ES) ."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Command Query Responsibility Segregation (CQRS)"><meta property="og:description" content="Command Query Responsibility Segregation (CQRS) is a architectural pattern that aims to split applications between two models: Command Model (writes) and Query Model (reads). Some use cases:
 Auditing (e.g., banking, accounting) High Scalability High Resiliency  This separation allows both concerns to evolve separately depending on the requirements. For example, some Aggregate Roots are a better fit for write models but do not fit other read models.
This pattern is often combined with Event Sourcing (ES) ."><meta property="og:type" content="article"><meta property="og:url" content="https://bphenriques.github.io/knowledge-base/notes/command_query_responsibility_segregation/"><meta property="article:section" content="notes"><title>Command Query Responsibility Segregation (CQRS) | Bruno Henriques's Digital Garden ðŸŒ±</title><link rel=icon href=/knowledge-base/favicon.png type=image/x-icon><link rel=stylesheet href=/knowledge-base/scss/explorer.min.81227fe14d47ca25b022b9b15feec75f9eb2a749e8453568ef9edad255a06da9.css integrity="sha256-gSJ/4U1HyiWwIrmxX+7HX56yp0noRTVo757a0lWgbak=" crossorigin=anonymous><script defer src=/knowledge-base/js/vendor/flexsearch.bundle.js></script><script defer src=/knowledge-base/js/search.min.f194e85d309adae058282f0ea2266359fe8ec0a80095467ac13c18625cd3a197.js integrity="sha256-8ZToXTCa2uBYKC8OoiZjWf6OwKgAlUZ6wTwYYlzToZc=" crossorigin=anonymous></script><script defer src=/knowledge-base/js/clipboard.min.14b9ccf5803971502776b44d95026b084e5fa02a544dc0e4cd86a7db76f691b2.js integrity="sha256-FLnM9YA5cVAndrRNlQJrCE5foCpUTcDkzYan23b2kbI=" crossorigin=anonymous></script></head><body><input type=checkbox class="hidden toggle" id=site-menu-control>
<input type=checkbox class="hidden toggle" id=content-menu-control><main class="container flex"><aside class=site-menu><div class=site-menu-content><nav><h2 class=brand><a class="flex align-center" href=/knowledge-base/><span>Bruno Henriques</span></a></h2><div class=search><input type=text id=search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="search-spinner hidden"></div><ul id=search-results class=item-preview-list></ul></div><a class=site-menu-shortcut-link href=/knowledge-base/notes>Recent Notes</a><p class=site-menu-tags-title><b>Tags</b></p><ul><li><a class=list-tag-item href=/knowledge-base/tags/akka><div class=tag-dot style=background-color:#ffecb3></div>Akka</a></li><li><a class=list-tag-item href=/knowledge-base/tags/aws><div class=tag-dot style=background-color:#f5f5f5></div>Aws</a></li><li><a class=list-tag-item href=/knowledge-base/tags/concurrency><div class=tag-dot style=background-color:#f5f5f5></div>Concurrency</a></li><li><a class=list-tag-item href=/knowledge-base/tags/data><div class=tag-dot style=background-color:#ffe0b2></div>Data</a></li><li><a class=list-tag-item href=/knowledge-base/tags/data-structures><div class=tag-dot style=background-color:#ffcdd2></div>Data structures</a></li><li><a class=list-tag-item href=/knowledge-base/tags/databases><div class=tag-dot style=background-color:#f1f8e9></div>Databases</a></li><li><a class=list-tag-item href=/knowledge-base/tags/dispatcher><div class=tag-dot style=background-color:#c8e6c9></div>Dispatcher</a></li><li><a class=list-tag-item href=/knowledge-base/tags/docker><div class=tag-dot style=background-color:#b9f6ca></div>Docker</a></li><li><a class=list-tag-item href=/knowledge-base/tags/docker-compose><div class=tag-dot style=background-color:#ffe0b2></div>Docker compose</a></li><li><a class=list-tag-item href=/knowledge-base/tags/dotfiles><div class=tag-dot style=background-color:#ab9df2></div>Dotfiles</a></li><li><a class=list-tag-item href=/knowledge-base/tags/editors><div class=tag-dot style=background-color:#ffb74d></div>Editors</a></li><li><a class=list-tag-item href=/knowledge-base/tags/flakes><div class=tag-dot style=background-color:#c8e6c9></div>Flakes</a></li><li><a class=list-tag-item href=/knowledge-base/tags/functional-programming><div class=tag-dot style=background-color:#ffebee></div>Functional programming</a></li><li><a class=list-tag-item href=/knowledge-base/tags/jq><div class=tag-dot style=background-color:#e1f5fe></div>Jq</a></li><li><a class=list-tag-item href=/knowledge-base/tags/json><div class=tag-dot style=background-color:#ffebee></div>JSON</a></li><li><a class=list-tag-item href=/knowledge-base/tags/jvm><div class=tag-dot style=background-color:#90caf9></div>Jvm</a></li><li><a class=list-tag-item href=/knowledge-base/tags/kotlin><div class=tag-dot style=background-color:#ffe57f></div>Kotlin</a></li><li><a class=list-tag-item href=/knowledge-base/tags/lightbend><div class=tag-dot style=background-color:#f0f4c3></div>Lightbend</a></li><li><a class=list-tag-item href=/knowledge-base/tags/monitoring><div class=tag-dot style=background-color:#e3f2fd></div>Monitoring</a></li><li><a class=list-tag-item href=/knowledge-base/tags/nix><div class=tag-dot style=background-color:#c5e1a5></div>Nix</a></li><li><a class=list-tag-item href=/knowledge-base/tags/note><div class=tag-dot style=background-color:#bbdefb></div>Note</a></li><li><a class=list-tag-item href=/knowledge-base/tags/postgres><div class=tag-dot style=background-color:#b2dfdb></div>Postgres</a></li><li><a class=list-tag-item href=/knowledge-base/tags/protocols><div class=tag-dot style=background-color:#ab9df2></div>Protocols</a></li><li><a class=list-tag-item href=/knowledge-base/tags/psql><div class=tag-dot style=background-color:#e0f2f1></div>Psql</a></li><li><a class=list-tag-item href=/knowledge-base/tags/queue><div class=tag-dot style=background-color:#ffebee></div>Queue</a></li><li><a class=list-tag-item href=/knowledge-base/tags/reference><div class=tag-dot style=background-color:#00bfa5></div>Reference</a></li><li><a class=list-tag-item href=/knowledge-base/tags/router><div class=tag-dot style=background-color:#c8e6c9></div>Router</a></li><li><a class=list-tag-item href=/knowledge-base/tags/scala><div class=tag-dot style=background-color:#ffd180></div>Scala</a></li><li><a class=list-tag-item href=/knowledge-base/tags/security><div class=tag-dot style=background-color:#b3e5fc></div>Security</a></li><li><a class=list-tag-item href=/knowledge-base/tags/signing><div class=tag-dot style=background-color:#ffd866></div>Signing</a></li><li><a class=list-tag-item href=/knowledge-base/tags/snippets><div class=tag-dot style=background-color:#e1f5fe></div>Snippets</a></li><li><a class=list-tag-item href=/knowledge-base/tags/stream><div class=tag-dot style=background-color:#d1c4e9></div>Stream</a></li><li><a class=list-tag-item href=/knowledge-base/tags/system-design><div class=tag-dot style=background-color:#ffebee></div>System design</a></li><li><a class=list-tag-item href=/knowledge-base/tags/testing><div class=tag-dot style=background-color:#e0e0e0></div>Testing</a></li><li><a class=list-tag-item href=/knowledge-base/tags/work><div class=tag-dot style=background-color:#f5f5f5></div>Work</a></li><li><a class=list-tag-item href=/knowledge-base/tags/zettelkasten><div class=tag-dot style=background-color:#e3f2fd></div>Zettelkasten</a></li></ul></nav></div></aside><div class=page><header class=mobile-navigation-header><div class="flex align-center justify-between"><label for=site-menu-control><img src=/knowledge-base/svg/menu-page.svg class=icon alt="Page Menu"></label>
<strong>Command Query Responsibility Segregation (CQRS)</strong>
<label for=content-menu-control><img src=/knowledge-base/svg/menu-content.svg class=icon alt="Content Menu"></label></div></header><article class=markdown><h1 class=post-title><a href=/knowledge-base/notes/command_query_responsibility_segregation/>Command Query Responsibility Segregation (CQRS)</a></h1><p>Command Query Responsibility Segregation (CQRS) is a architectural pattern that aims to split applications between two models: <code>Command Model</code> (writes) and <code>Query Model</code> (reads). Some use cases:</p><ul><li>Auditing (e.g., banking, accounting)</li><li>High Scalability</li><li>High Resiliency</li></ul><p>This separation allows both concerns to evolve separately depending on the requirements. For example, some Aggregate Roots are a better fit for write models but do not fit other read models.</p><p>This pattern is often combined with <a href=/knowledge-base/notes/event_sourcing_es_es/>Event Sourcing (ES)</a>
.</p><p>Eventually consistent by design which always present but now is explicit about it.</p><h2 id=how>How:
<a class=anchor href=#how>#</a></h2><p>Application is split between two models:</p><ul><li><strong>Command Model</strong>: Handles requests to change the state of the application and decide its side-effects, e.g., events or new commands.</li><li><strong>Query Model</strong> (or View Model or Projection): Focus on data and not on behavior and are modelled to satisfy a very specific need, therefore it is usual having multiple of them.</li></ul><pre><code class=language-nil data-lang=nil>API -Queries-&gt; Read Model &lt;- Data Store
API -Commands-&gt; Write Model -&gt; Data Store
</code></pre><p>Separate process consumes the written events and persists on a denormalized event store, which is called <em>Projection</em> used by the read model like so:</p><pre><code class=language-nil data-lang=nil>API -Queries-&gt; Read Model &lt;- Data Store
API -Commands-&gt; Write Model -&gt; Data Store

Data Store -Events-&gt; Denormalized Data Store (with Projections)
</code></pre><p>The Data Store is usually denormalized to make sure that queries are faster.</p><h2 id=summary>Summary
<a class=anchor href=#summary>#</a></h2><ul><li>Write model are optimized for writes</li><li>Read models are optimized for reads</li><li>Read and write models are decoupled which implies that they may use different data stores.</li><li>New <em>Projections</em> are easy in CQRD/ES.</li><li>New projections are retroactive because we have the fully history.</li></ul><h2 id=models-as-microservices>Models as Microservices
<a class=anchor href=#models-as-microservices>#</a></h2><ul><li>Write Model can become a microservice</li><li>Read Model can become a microservice</li></ul><p>This assumes that it uses different databases (as expected from proper microservices). Otherwise the database may become the bottleneck.</p><p>Better yet: Each projection in its own Microservice. \[\]\[\]\[\] and maintentance.</p><h2 id=consistency>Consistency
<a class=anchor href=#consistency>#</a></h2><p>Simple (without ES) has the same consistency as non-CQRS systems.
CQRD/ES can have different consistency models for the read or the write models.</p><h3 id=write-model>Write Model
<a class=anchor href=#write-model>#</a></h3><p>Strong is often important here because we want that those write be based on the current state. This consistency is usually implemented through locks or sharding in a more reactive way.</p><h3 id=read-model>Read Model
<a class=anchor href=#read-model>#</a></h3><p>Pure reads are never consistent as they are often working with stale data. These reads do not need strong consistency.</p><h2 id=availability>Availability
<a class=anchor href=#availability>#</a></h2><h3 id=write-model>Write Model
<a class=anchor href=#write-model>#</a></h3><p>Due to the higher consistency, availability is lower.</p><h3 id=read-model>Read Model
<a class=anchor href=#read-model>#</a></h3><p>Due to the eventual consistency, we can leverage technicques to increase availability.</p><h2 id=cost>Cost
<a class=anchor href=#cost>#</a></h2><p>CQRD/ES is often criticized for being more complex but it can be simpler.
Without this, models are more bloated, complex and rigid.
CQRD allow smaller models that are easier to modify and understand.
Eventual consistency in CQRS can be isolated to where it is necessary.</p><ul><li>More databases to maintain</li><li>More classes/objects to maintain</li><li>Support older versions can be challenging</li><li>Additinonal storage</li><li>Data duplication may result in desyncs that often solved by rebuilding project - Question: <strong>when</strong> ? Do we have monitoring over this? Can this be automatic? How often does this occur?</li><li>UI must be designed to be eventually consistent (which was always there in the past, it is now explicit)</li></ul></article><footer class=page-footer></footer><label for=site-menu-control class="hidden site-menu-overlay"></label><label for=content-menu-control class="hidden content-menu-overlay"></label></div><aside class=content-menu><div class=content-menu-content><div class=toc-tags><p class=toc-title>Tags</p><div class=list-item-tag style=background-color:#ffebee>System design</div></div><p class=toc-title>Table Of Contents</p><nav id=TableOfContents><ul><li><a href=#how>How:</a></li><li><a href=#summary>Summary</a></li><li><a href=#models-as-microservices>Models as Microservices</a></li><li><a href=#consistency>Consistency</a><ul><li><a href=#write-model>Write Model</a></li><li><a href=#read-model>Read Model</a></li></ul></li><li><a href=#availability>Availability</a><ul><li><a href=#write-model>Write Model</a></li><li><a href=#read-model>Read Model</a></li></ul></li><li><a href=#cost>Cost</a></li></ul></nav><nav class=backlinks><p class=toc-title>Mentioned In</p><ul class=item-preview-list><li><a href=/knowledge-base/notes/domain_driven_design/><div class=item-preview><span class=item-preview-title>Domain Driven Design</span><br><span class=item-preview-content>Approach on Software Development focused on the design of a shared Model understood by â€¦</span></div></a></li><li><a href=/knowledge-base/notes/event_sourcing_es_es/><div class=item-preview><span class=item-preview-title>Event Sourcing (ES)</span><br><span class=item-preview-content>Representing the application&rsquo;s state through the history of events that have â€¦</span></div></a></li></ul></nav></div></aside></main></body></html>