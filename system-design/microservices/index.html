<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Referred in
 Service Oriented Architecture   Subset of Service Oriented Architecture where each service is deployed separately:
 Microservices can be physically separated and independently deployed. Each have its own data store. Independent and self governing. Communication is syncronous or asyncronous (e.g., through message brokers). Loose coupling between components (more or less by experience but that is design flaw likely :thinking:). Shorter development and release cycles. Each scale independently (either through physical or virtual machines)."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Microservices"><meta property="og:description" content="Referred in
 Service Oriented Architecture   Subset of Service Oriented Architecture where each service is deployed separately:
 Microservices can be physically separated and independently deployed. Each have its own data store. Independent and self governing. Communication is syncronous or asyncronous (e.g., through message brokers). Loose coupling between components (more or less by experience but that is design flaw likely :thinking:). Shorter development and release cycles. Each scale independently (either through physical or virtual machines)."><meta property="og:type" content="article"><meta property="og:url" content="https://bphenriques.github.io/knowledge-base/system-design/microservices/"><title>Microservices | Bruno Henriques</title><link rel=manifest href=/knowledge-base/manifest.json><link rel=icon href=/knowledge-base/favicon.png type=image/x-icon><link rel=stylesheet href=/knowledge-base/book.min.19256db6edae397ffaff8a50dfd331f9f5f916ae4720b444fb87a8d48e9a61f0.css integrity="sha256-GSVttu2uOX/6/4pQ39Mx+fX5Fq5HILRE+4eo1I6aYfA="><script defer src=/knowledge-base/en.search.min.c636e9f06cc6c28e840d746d58f33f7cb5bcbc3f9d09bd7bd7d2965884e5f163.js integrity="sha256-xjbp8GzGwo6EDXRtWPM/fLW8vD+dCb1719KWWITl8WM="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/knowledge-base><span>Bruno Henriques</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Concurrency</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/concurrency/actor-model/>Actor Model</a></li></ul></li><li class=book-section-flat><span>Data Processing</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/data-processing/apache-spark/>Apache Spark</a></li><li><a href=https://bphenriques.github.io/knowledge-base/data-processing/states-of-data/>States of Data</a></li></ul></li><li class=book-section-flat><span>Documentation</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/documentation/readme/>readme</a></li></ul></li><li class=book-section-flat><span>Learning</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/learning/hands_on_scala_programming/>Hands-on Scala Programming</a></li></ul></li><li class=book-section-flat><span>Messaging Systems</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/messaging-systems/overview/>Messaging Systems Comparison</a></li></ul></li><li class=book-section-flat><span>Monitoring</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/monitoring/bug-management/>Bug Management</a></li></ul></li><li class=book-section-flat><span>Security</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/security/jwt/>JWT</a></li></ul></li><li class=book-section-flat><span>System Design</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/system-design/command_sourcing/>Command Sourcing</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/>Consistency And Availability</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/cqrs_es/>CQRS/ES</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/distribute_systems/>Distributed Systems</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/>Domain Driven Design</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/event_sourcing/>Event Sourcing</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/>Message Driven Architecture</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/microservices/ class=active>Microservices</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/monolith/>Monolith</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/reactive_systems/>Reactive Systems</a></li><li><a href=https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture/>Service Oriented Architecture</a></li></ul></li><li class=book-section-flat><span>Work</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/work/random-memories/>Random Memories</a></li><li><a href=https://bphenriques.github.io/knowledge-base/work/way-of-work/>Way of work</a></li></ul></li><li class=book-section-flat><span>Snippets</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/snippets/jackson/>Jackson</a></li></ul></li><li class=book-section-flat><span>Blog Ideas</span><ul></ul></li><li class=book-section-flat><span>Uncategorized</span><ul><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/akka/>Akka</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/lightbend-academy/>Lightbend Academy</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/org_protocol/>Org-Protocol</a></li><li><a href=https://bphenriques.github.io/knowledge-base/uncategorized/relevant-xkcds/>Relevant xkcds</a></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/knowledge-base/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Microservices</strong>
<label for=toc-control><img src=/knowledge-base/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#advantages>Advantages</a></li><li><a href=#disanvantages>Disanvantages</a></li><li><a href=#designing-one>Designing one</a></li><li><a href=#principles-of-isolation>Principles of Isolation</a><ul><li><a href=#state>State</a></li><li><a href=#space>Space</a></li><li><a href=#time>Time</a></li><li><a href=#failure>Failure</a></li></ul></li><li><a href=#isolation-techniques>Isolation Techniques</a><ul><li><a href=#bulkheading>Bulkheading</a></li><li><a href=#circuit-breaker>Circuit Breaker</a></li><li><a href=#message-driven-architecture>Message Driven Architecture</a></li><li><a href=#autonomy>Autonomy</a></li><li><a href=#api-gateway-services>API Gateway Services</a></li></ul></li></ul></nav></aside></header><article class=markdown><div class=backlinks><div></div><p>Referred in</p><ul><li><a href=/knowledge-base/system-design/service_oriented_architecture/>Service Oriented Architecture</a></li></ul></div><p>Subset of <a href=/knowledge-base/system-design/service_oriented_architecture/>Service Oriented Architecture</a> where each service is deployed separately:</p><ul><li>Microservices can be physically separated and independently deployed.</li><li>Each have its own data store.</li><li>Independent and self governing.</li><li>Communication is syncronous or asyncronous (e.g., through <a href=/knowledge-base/messaging-systems/overview/>message brokers</a>).</li><li>Loose coupling between components (more or less by experience but that is design flaw likely :thinking:).</li><li>Shorter development and release cycles.</li><li>Each scale independently (either through physical or virtual machines).</li></ul><h2 id=advantages>Advantages
<a class=anchor href=#advantages>#</a></h2><ul><li>Deployed/Scaled as needed.</li><li>Increase availability due to reduced single point of failures.</li><li>Better isolation leading to less couling giving flexibility.</li><li>Supports multiple platforms and languages.</li><li>More indepentent</li><li>Shorter cycles</li></ul><p>Mention that cross team coordination become less necessary. That is true but often it still is and requires coordination.</p><h2 id=disanvantages>Disanvantages
<a class=anchor href=#disanvantages>#</a></h2><ul><li>Require multiple complex deployment nad monitoring approaches.</li><li>Cross service refactors are more challenging.</li><li>Require supporting old versions.</li><li>Organization Change</li></ul><h2 id=designing-one>Designing one
<a class=anchor href=#designing-one>#</a></h2><ul><li>Single responsibility. A change to the internals of one microservice should not necessitate a change to another microservice.</li><li><a href=/knowledge-base/system-design/domain_driven_design/>Bounded Contexts</a> are a good place to start as they have clear boundaries with its own domain - Question: Can multiple microservices collectively encapsulate a bounded context?</li></ul><h2 id=principles-of-isolation>Principles of Isolation
<a class=anchor href=#principles-of-isolation>#</a></h2><h3 id=state>State
<a class=anchor href=#state>#</a></h3><p>All access must go thorugh the API and there is no backdoors. Allows internal changes without affecting others.</p><h3 id=space>Space
<a class=anchor href=#space>#</a></h3><p>Should not care where the other services are deployed. Allows microservices to be scaled up or down to meet demands. However, if latency is an issue, they should be in the same region.</p><h3 id=time>Time
<a class=anchor href=#time>#</a></h3><p>Should not wait for each other which allows more efficient use of resources. Resources can be freed immediatly, rather than waiting for a request to finish.</p><p>Between microservices we expect eventual consistency. It improves scalability as total consitency requires central coordination which hindes scalability.</p><p>NOTE: This is discussible. However it may be a implementation details.</p><h3 id=failure>Failure
<a class=anchor href=#failure>#</a></h3><p>Isolate failures and should not cause failure on other systems. I.e., it still is responsive to attend other use-cases.</p><h2 id=isolation-techniques>Isolation Techniques
<a class=anchor href=#isolation-techniques>#</a></h2><h3 id=bulkheading>Bulkheading
<a class=anchor href=#bulkheading>#</a></h3><p>Failures are isolated to failure zones. Failures in one service will not propagate to other services. Overall the system remains operation but possibly in a degraded state.</p><p>In practice it means that that systems that depend on the service that is considered a failure zone, will mark that information or service as unavailable. IMO this is tolerable if the service is non-critical.</p><h3 id=circuit-breaker>Circuit Breaker
<a class=anchor href=#circuit-breaker>#</a></h3><p>When a service is under stress we do not want to keep on retrying as it may make things worse.</p><p>Way to avoid overloading a service. They qaurantine a failing service so it can <em>fail fast</em>. Allows the failing service to recover in its time before they fail.</p><p>Types:</p><ul><li>Closed - Normal Operation</li><li>Open - Fail fast</li><li>Half Open - Internally after a timeout will let one request to go through and if it fails, it goes back to Open.</li></ul><p>Transitions:</p><ul><li>Closed (normal) -> Trip: Open (Fail Fast)</li><li>Open (Fail fast) -> Attempt Reset: Half Open</li><li>Half Open -> Trip: Open (fail Fast)</li><li>Half Open -> Reset: Closed (Normal)</li></ul><h3 id=message-driven-architecture>Message Driven Architecture
<a class=anchor href=#message-driven-architecture>#</a></h3><ul><li>Async and non blocking messages allows decoupling both time and failure.</li><li>System do not depend on the response from on another.</li><li>If a request to a service fails, the failure will not propagated.</li><li>The client service isn&rsquo;t waiting for response. It can continue to operate normally.</li></ul><h3 id=autonomy>Autonomy
<a class=anchor href=#autonomy>#</a></h3><p>Services can operate independently from each other.</p><p>Autonomous services have enough information to resolve conflicts and repair failures. This means that they do not require other services to be operational all the time. Ideally all the time but in reality for a short time it guarantees some level of autonomy.</p><p>Benefits:</p><ul><li>Stronger scalability and availability.</li><li>Can be scaled indefinetly.</li><li>Operate independently.</li></ul><p>How:</p><ul><li>Async messages.</li><li>Maintain enough internal state ofr the microservices to function in isolation.</li><li>Use eventual consistency.</li><li>Avoid direct, syncronous dependencies on external services.</li></ul><h3 id=api-gateway-services>API Gateway Services
<a class=anchor href=#api-gateway-services>#</a></h3><p>Microservices can lead to complexity in the API. How can we manage complex APIs that access many microservices?</p><p>A new microservice that is put between the client and the N-services that are required to fulfill that request. This new microservice is responsible for aggregating the responses moving the responsbility from the client itself. This way, the client <strong>only</strong> needs to manage failures from the gateway.</p><p>This effectively creates an additional layer of isolation.</p><p>!! This is specially useful for mobile applicatios where we cannot guarantee that the clients will update their app.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div><a class="flex align-center" href=https://github.com/bphenriques/knowledge-base/edit/master/org/system-design/microservices.org target=_blank rel=noopener><img src=/knowledge-base/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#advantages>Advantages</a></li><li><a href=#disanvantages>Disanvantages</a></li><li><a href=#designing-one>Designing one</a></li><li><a href=#principles-of-isolation>Principles of Isolation</a><ul><li><a href=#state>State</a></li><li><a href=#space>Space</a></li><li><a href=#time>Time</a></li><li><a href=#failure>Failure</a></li></ul></li><li><a href=#isolation-techniques>Isolation Techniques</a><ul><li><a href=#bulkheading>Bulkheading</a></li><li><a href=#circuit-breaker>Circuit Breaker</a></li><li><a href=#message-driven-architecture>Message Driven Architecture</a></li><li><a href=#autonomy>Autonomy</a></li><li><a href=#api-gateway-services>API Gateway Services</a></li></ul></li></ul></nav></aside></main></body></html>