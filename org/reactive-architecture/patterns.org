#+SETUPFILE: ./_index.org
#+ROAM_TAGS: reactive
#+ROAM_ALIAS:
#+TITLE: Patterns

*CQRS/ES*: Command Query Responsibility Segregation and Event Sourcing.

Two tools that can be combined.

Use Cases:
- Auditing (e.g., banking, accounting)
- High Scalability
- High Resiliency

There are trade-offs, what are they?

* State Based Persistence

* CQRS

State Based Persistence. Every time an update is applied to the database it obliterates previous state.

- Can't fix bad state due to previous error.
- Can't retroactively apply new domain insights (because we do not have the previous states).

This solely tells where we are but not how we got there:
These limitations can be worked around with Event Sourcing (ES)

* Event Sourcing (ES)

In addition to persisting state, one persists audit logs. This captures the history. It is better to have this in a database as it provides transactionality.

Wary when persisting in the database and in-memory:
- Two potential source of truth if they disagree.
- Both must be updated in transactionality.
- A bug in the code may lead to both of them becoming out-of-sync.

Q: What happens if the audit logs gets out-of-sync with the state?
A: The audit logs is the source of truth as, as opposition, is not possible to rebuild the audit logs from the current state.

This leads to not requiding storing the current state. Event Sourcing captures the intent.

Whenever we need to obtain the current state we replay the logs until we reach the current state. Attention: We mustn't also replay the side-effects.

Append-only is also more efficient in the databases - No deletions or updates.

Event Integrity: The logs are the most important thing and should never be rewritten -> immutable events.

** Optimization through snapshots

What happens if the list of events is too large?
Solution: Ocasionally persist a snapshot and we replay the events from that point on (issue: We may receive an event out-of-order, invalidating the snapshot).

** Versioning

Issue when we have to change the event's schema. This leads to ~ModelV1~, ~ModelV2~, etc. This requires _supporting_ all versions. And requires flexibile formats: JSON, ProtoBuf or AkkA Event Adapters in the lightbend ecosystem that is between the system and the DB translating the ~V1~, ~V2~, ~VN~ to the corresponding and unique Domain entity.

* Command Sourcing

Similar to command sourcing but persists commands as opposed to events so:
1. Issue command
2. Persist command
3. Run asyncronous the command

- They should be idempotent as they run multiple times (e.g., failures).
- Must be validated so that they do not become stuck in the queue forever.
- Bad: The sender might not be notified if the command fails due to the decouple nature.
