<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>data-structures on Bruno Henriques's Digital Garden ðŸŒ±</title><link>https://bphenriques.github.io/knowledge-base/tags/data-structures/</link><description>Recent content in data-structures on Bruno Henriques's Digital Garden ðŸŒ±</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://bphenriques.github.io/knowledge-base/tags/data-structures/index.xml" rel="self" type="application/rss+xml"/><item><title>Scala Experiments</title><link>https://bphenriques.github.io/knowledge-base/notes/scala_experiments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/scala_experiments/</guid><description>Implementing Tree # sealed class Tree[T] { def stream(): LazyList[T] = this match { case Leaf(value) =&amp;gt; LazyList(value) case Branch(left, right) =&amp;gt; left.stream() #::: right.stream() } } case class Branch[T](left: Tree[T], right: Tree[T]) extends Tree[T] case class Leaf[T](value: T) extends Tree[T] val tree = Branch( Leaf(1), Branch( Leaf(2), Leaf(3) ) ) val nextInOrder = tree.stream().dropWhile(_ != 2).drop(1).headOption println(nextInOrder)</description></item></channel></rss>