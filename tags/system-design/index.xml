<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>system-design on Bruno Henriques's Digital Garden ðŸŒ±</title><link>https://bphenriques.github.io/knowledge-base/tags/system-design/</link><description>Recent content in system-design on Bruno Henriques's Digital Garden ðŸŒ±</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://bphenriques.github.io/knowledge-base/tags/system-design/index.xml" rel="self" type="application/rss+xml"/><item><title>BASE Transaction</title><link>https://bphenriques.github.io/knowledge-base/notes/base_transaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/base_transaction/</guid><description>Sometimes ACID transactions are not possible in some cases, e.g., microservices. As alternative, we use BASE transactions:
Basically Available Soft State Eventual Consistency The difference from ACID transactions it that they cannot be rolledback easily. To rollback, a compensating action is needed to revert to the original state. Saga manages these kind of transactions and are often used to manage different aggregate roots (see Domain Driven Design ).</description></item><item><title>Command Query Responsibility Segregation (CQRS)</title><link>https://bphenriques.github.io/knowledge-base/notes/command_query_responsibility_segregation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/command_query_responsibility_segregation/</guid><description>Command Query Responsibility Segregation (CQRS) is a architectural pattern that aims to split applications between two models: Command Model (writes) and Query Model (reads). Some use cases:
Auditing (e.g., banking, accounting) High Scalability High Resiliency This separation allows both concerns to evolve separately depending on the requirements. For example, some Aggregate Roots are a better fit for write models but do not fit other read models.
This pattern is often combined with Event Sourcing (ES) .</description></item><item><title>Command Sourcing</title><link>https://bphenriques.github.io/knowledge-base/notes/command_sourcing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/command_sourcing/</guid><description>Command Sourcing # Similar to Event Sourcing (ES) but persists commands as opposed to events so:
Issue command
Persist command
Run asyncronous the command
They should be idempotent as they run multiple times (e.g., failures).
Must be validated so that they do not become stuck in the queue forever.
Bad: The sender might not be notified if the command fails due to the decouple nature.</description></item><item><title>Consistency And Availability</title><link>https://bphenriques.github.io/knowledge-base/notes/consistency_and_availability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/consistency_and_availability/</guid><description>Scalability # It can meets increases in demand while remaining responsive.
This is different from performance. Performance optimizes response time (latency) while scalability optimizes ability to handle load. Requests per second actually measures both but we do not know which aspect was improved.
Note Scalability is not the number of requests qwe can handle a in a given period of time (req/sec) but he number of requests itself (load).</description></item><item><title>Domain Driven Design</title><link>https://bphenriques.github.io/knowledge-base/notes/domain_driven_design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/domain_driven_design/</guid><description>Approach on Software Development focused on the design of a shared Model understood by domain experts and by who implements it. Being a model, it means that it can be implemented in different ways, from diagrams to software.
Concepts # Context: The setting a word appers determines its meaning. Domain: Sphere of knowledge, influence or activity (aka area). Model: System of abstractions that describes a part of the domain.</description></item><item><title>Event Sourcing (ES)</title><link>https://bphenriques.github.io/knowledge-base/notes/event_sourcing_es_es/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/event_sourcing_es_es/</guid><description>Representing the application&amp;rsquo;s state through the history of events that have happened in the past. Use cases:
Audit Logs: Build tailored reports from the event stream. Analytics: Extract behavior from the event stream. Temporal Reports: Build the timeline that led to a certain state. This is the opposite of regular applications where the final state is stored. In Event Sourced applications, the final state is called Materialized State. Whenever we need to obtain the current state we replay the logs until we reach the current state without replaying the side-effects.</description></item><item><title>Message Driven Architecture</title><link>https://bphenriques.github.io/knowledge-base/notes/message_driven_architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/message_driven_architecture/</guid><description>Asyncronous and non-blocking. The sender does not actively wait for a response.
Advantages:
Resources are freed immediatly. Reduced contention Messages can be queued for deleivery in case the receiver&amp;rsquo;s is offline. Provides a higher level of reliability. Disavantages:
Make transactions more difficult. How to manage long running transactions that span multiple microservices. Holding transactions open for long periods result in slow, brittle systems. The role of syncronous messags:</description></item><item><title>Microservices</title><link>https://bphenriques.github.io/knowledge-base/notes/microservices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/microservices/</guid><description>Subset of Service Oriented Architecture (SOA) where each service is deployed separately:
Microservices can be physically separated and independently deployed. Each have its own data store. Independent and self governing. Communication is syncronous or asyncronous (e.g., through messaging systems ). Loose coupling between components (more or less by experience but that is design flaw likely :thinking:). Shorter development and release cycles. Each scale independently (either through physical or virtual machines).</description></item><item><title>Monolith</title><link>https://bphenriques.github.io/knowledge-base/notes/monolith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/monolith/</guid><description>Charateristics # Deployed as a single unit. No Clear Isolation. Complex Depedencies which in turn makes it hard to understand and modify. Big Bang Style Releases Long Cycle Times Careful releases Scalation is done with multiple copies and uses the database as consistency between them. Advantages: # Easy Cross Module Refactor Easier to maitain consistency Single Deploy Process Single thing to monitor Simple Scalability Model Disavantages: # Limited by the maximum size of a single phyisical machine.</description></item><item><title>Reactive Streams</title><link>https://bphenriques.github.io/knowledge-base/notes/reactive_streams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/reactive_streams/</guid><description>Components of a Reactive Stream:
Publisher: Publishes data to stream Subscriber: Consumes data from the stream. Processor: Acts as both a publisher and a subscriber, obeying the contract for each. Subscription: Connects a subscriber to a publisher to initiate a message flow. Akka Streams is built on these concepts but provides a different API (albeit is possible to bridge).</description></item><item><title>Reactive Systems</title><link>https://bphenriques.github.io/knowledge-base/notes/reactive_systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/reactive_systems/</guid><description>Goal # Provide an experience that is responsive under all conditions. Note that reactive programming is not the same as reactive systems.
This requires:
Ability to scale from 10 users to million of users. Consume solely the resources required to support the current work-load. Reactive Principles # Systems that apply the following principles are considered reactive systems (see more here ).
Responsive # Always respond in a timely manner.</description></item><item><title>Saga</title><link>https://bphenriques.github.io/knowledge-base/notes/saga/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/saga/</guid><description>Applied in microservices to manage complex workflows that may fail and need to be rolledback.
This document requires more details.</description></item><item><title>Service Oriented Architecture (SOA)</title><link>https://bphenriques.github.io/knowledge-base/notes/service_oriented_architecture_soa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/service_oriented_architecture_soa/</guid><description>TODO REVIEW THESE NOTES - Architectural Patterns # As opposed to Monolith , services do not share a database and all access must be done through a API exposed by the service. They may be in the same process (Monolith ) or may be separated (Microservices ). This reduces coupling.</description></item><item><title>Sharding or Partitioning</title><link>https://bphenriques.github.io/knowledge-base/notes/sharding_or_partitioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/sharding_or_partitioning/</guid><description>Technique used by some data stores to reduce contention without sacrificing consistency.
Records are distributed across nodes using a Shard Key or a Partition Key that will be used by the Database Router that redirects requests to the correct shard/partition.
Benefits:
Contention is isolated to a shard/partition. Given that each shard stores a part of the dataset, it is only handling a small part of the overall load. Improves elasticity.</description></item><item><title>SLI/SLO</title><link>https://bphenriques.github.io/knowledge-base/notes/sli_slo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/sli_slo/</guid><description>Service Level Indicator (SLI): Performance indicator measured as a ratio of two numbers. Service Level Objective (SLO): Defines a target SLI as measurment of the systems&amp;rsquo;s reliability. Service Level Agreement (SLA): Business contract regarding the expected SLO. It is far productive measuring them as use-histories as it defines the critical paths.</description></item><item><title>Stateless</title><link>https://bphenriques.github.io/knowledge-base/notes/stateless/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/notes/stateless/</guid><description>Requests are self-contained and have all the information required to be completed. Requests can be processed on any instance of the application. Some &amp;ldquo;Stateless&amp;rdquo; systems are not trully stateless as the state is contained in a database:
Required to have strong consistency (the single source of truth). However this means that the database may become the bottleneck. The database also represents the single point of failure which may lead to an unresponsive systems.</description></item></channel></rss>