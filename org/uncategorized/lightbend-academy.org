#+TITLE: Lightbend Academy
#+SETUPFILE: ./_index.org

* Reactive Programming vs Reactive Systems

They are not the same.

Reactive systems apply the reactive principles on a architectural level.

Reactive Programming can be (and often is) used to build reactive systems but that does not mean that it is a reactive system.

In order to have a reactive architecture, it means that the reactive systems needs to be separated thorugh asyncronous boundaries.

* TODO https://www.lightbend.com/white-papers-and-reports/reactive-programming-versus-reactive-systems


* Domain Driven Design

Goal: Software implementation that is based on an evolving model that is understood by the domain experts.

Domain: Sphere knowledge. Referes to busuiness or idea we are trying to model.

THe software is the implementation of such domain that experts are able to understand.

Goal: Build a model that domain expderts understand. One that we show them without they understanding the Software.

LEads to a way to communicate with them.

It is important to mention that the model is not hte software. Model represents the understanding of hte domain. The softewrae is solely the implementation of hte model. It can be implemented on diagrams which is not software but an implementation nonetheless.

But the software should be implemented in a way that reflecfts the model in a way that 1:1 parity between the model and the implementation.

This requires a common language that both parties. understand leading to:
- Ubiquitous Language: Common language that enables communication between the domain experts and the developers. Terminologuy in there comes from the domain experts. Software termms should be avoided. However sometimes we have to introduce soem terms to the language and such terms should go through the domain experts as well as they may have already a work for that.


** Decomposing

Business domains are typically large and complicated. With many ideas, actions and rules taht interact in complex ways.

Strategy: Take the large domain and seperate onto sub domains by grouping related ideas, actions and rules - Maybe use-cases?

However it is normal having conceps that span multiple sub domains however it is important to avoid abstract already as there may be slight changes. For example, a customer in the context of an online order is different from a customer in the context of in-store purchase. Therefore, there should be modeled as different entities.

Bounded Context: Ubiquotious Language and model for a sub-domain. The meaning of a concept by change from one bounded context to another.

Microservices are built around bounded contexts.

How to determine those boundaries? Some guidelines:
- IMO Use-cases...
- Consider human culture and interactions, i.e., how different groups of people interact with a given entity.
- Look for changes in the ubiquitous language. Variations suggest a new context.
- Look for variations where the informatio become relevant/irrelevant.

Strongly separated bounded contexts reuslt in smooth workflows.


If it awkwards it may be due to a misunderstanding of the domain.

** Event First Domain Driven Design

Look at the activities (i.e. use-cases?) and start grouping such activities.


* Other

** TODO There is a thing called Reactive Manifesto
https://github.com/reactivemanifesto/reactivemanifesto
