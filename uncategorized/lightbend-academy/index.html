<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Referred in
 Domain Driven Design   Reactive Programming vs Reactive Systems They are not the same.
Reactive systems apply the reactive principles on a architectural level.
Reactive Programming can be (and often is) used to build reactive systems but that does not mean that it is a reactive system.
In order to have a reactive architecture, it means that the reactive systems needs to be separated thorugh asyncronous boundaries."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Lightbend Academy"><meta property="og:description" content="Referred in
 Domain Driven Design   Reactive Programming vs Reactive Systems They are not the same.
Reactive systems apply the reactive principles on a architectural level.
Reactive Programming can be (and often is) used to build reactive systems but that does not mean that it is a reactive system.
In order to have a reactive architecture, it means that the reactive systems needs to be separated thorugh asyncronous boundaries."><meta property="og:type" content="article"><meta property="og:url" content="https://bphenriques.github.io/knowledge-base/uncategorized/lightbend-academy/"><title>Lightbend Academy | Bruno Henriques</title><link rel=manifest href=/knowledge-base/manifest.json><link rel=icon href=/knowledge-base/favicon.png type=image/x-icon><link rel=stylesheet href=/knowledge-base/book.min.80dcfd7259b9a5c0241332dff7cc1804ec3a8d90b9185d46ebc1da2f321d48b3.css integrity="sha256-gNz9clm5pcAkEzLf98wYBOw6jZC5GF1G68HaLzIdSLM="><script defer src=/knowledge-base/en.search.min.f37dba06bd04b2a13f680308510553a0b61d82f701ca3315f0039e5ba2ea7628.js integrity="sha256-8326Br0EsqE/aAMIUQVToLYdgvcByjMV8AOeW6Lqdig="></script></head><body><input type=checkbox class=hidden id=menu-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/knowledge-base><span>Bruno Henriques</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Concurrency</span><ul><li><a href=/knowledge-base/concurrency/actor-model/>Actor Model</a></li></ul></li><li class=book-section-flat><span>Data Processing</span><ul><li><a href=/knowledge-base/data-processing/apache-spark/>Apache Spark</a></li><li><a href=/knowledge-base/data-processing/states-of-data/>States of Data</a></li></ul></li><li class=book-section-flat><span>Documentation</span><ul><li><a href=/knowledge-base/documentation/readme/>Readme</a></li></ul></li><li class=book-section-flat><span>Editors</span><ul><li><a href=/knowledge-base/editors/emacs/>Emacs</a></li></ul></li><li class=book-section-flat><span>Learning</span><ul><li><a href=/knowledge-base/learning/hands_on_scala_programming/>Hands-on Scala Programming</a></li></ul></li><li class=book-section-flat><span>Messaging Systems</span><ul><li><a href=/knowledge-base/messaging-systems/overview/>Messaging Systems Comparison</a></li></ul></li><li class=book-section-flat><span>Monitoring</span><ul><li><a href=/knowledge-base/monitoring/bug-management/>Bug Management</a></li></ul></li><li class=book-section-flat><span>Security</span><ul><li><a href=/knowledge-base/security/jwt/>JWT</a></li></ul></li><li class=book-section-flat><span>System Design</span><ul><li><a href=/knowledge-base/system-design/command_query_responsibility_segregation/>Command Query Responsibility Segregation (CQRS)</a></li><li><a href=/knowledge-base/system-design/command_sourcing/>Command Sourcing</a></li><li><a href=/knowledge-base/system-design/consistency_and_availability/>Consistency And Availability</a></li><li><a href=/knowledge-base/system-design/cqrs_es/>CQRS/ES</a></li><li><a href=/knowledge-base/system-design/domain_driven_design/>Domain Driven Design</a></li><li><a href=/knowledge-base/system-design/event_sourcing/>Event Sourcing</a></li><li><a href=/knowledge-base/system-design/message_driven_architecture/>Message Driven Architecture</a></li><li><a href=/knowledge-base/system-design/microservices/>Microservices</a></li><li><a href=/knowledge-base/system-design/monolith/>Monolith</a></li><li><a href=/knowledge-base/system-design/reactive_systems/>Reactive Systems</a></li><li><a href=/knowledge-base/system-design/service_oriented_architecture/>Service Oriented Architecture</a></li></ul></li><li class=book-section-flat><span>Work</span><ul><li><a href=/knowledge-base/work/curriculum/>Curriculum</a></li><li><a href=/knowledge-base/work/random-memories/>Random Memories</a></li><li><a href=/knowledge-base/work/way-of-work/>Way of work</a></li></ul></li><li class=book-section-flat><span>Snippets</span><ul><li><a href=/knowledge-base/snippets/emacs/>Emacs</a></li><li><a href=/knowledge-base/snippets/jackson/>Jackson</a></li></ul></li><li class=book-section-flat><span>Blog Ideas</span><ul></ul></li><li class=book-section-flat><span>Uncategorized</span><ul><li><a href=/knowledge-base/uncategorized/akka/>Akka</a></li><li><a href=/knowledge-base/uncategorized/dotfiles/>dotfiles</a></li><li><a href=/knowledge-base/uncategorized/event_sourcing/>Event Sourcing</a></li><li><a href=/knowledge-base/uncategorized/lightbend-academy/ class=active>Lightbend Academy</a></li><li><a href=/knowledge-base/uncategorized/nix/>Nix</a></li><li><a href=/knowledge-base/uncategorized/nota_aleatoria/>nota aleatoria</a></li><li><a href=/knowledge-base/uncategorized/org_protocol/>Org-Protocol</a></li><li><a href=/knowledge-base/uncategorized/relevant-xkcds/>Relevant xkcds</a></li><li><a href=/knowledge-base/uncategorized/sobre_qq_coisa/>Sobre qq coisa</a></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/knowledge-base/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Lightbend Academy</strong>
<label for=toc-control><img src=/knowledge-base/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><input type=checkbox class=hidden id=toc-control><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#reactive-programming-vs-reactive-systems>Reactive Programming vs Reactive Systems</a></li><li><a href=#https-www-dot-lightbend-dot-com-white-papers-and-reports-reactive-programming-versus-reactive-systems><span class="org-todo todo TODO">TODO</span> <a href=https://www.lightbend.com/white-papers-and-reports/reactive-programming-versus-reactive-systems>https://www.lightbend.com/white-papers-and-reports/reactive-programming-versus-reactive-systems</a></a></li><li><a href=#domain-driven-design>Domain Driven Design</a><ul><li><a href=#decomposing>Decomposing</a></li><li><a href=#event-first-domain-driven-design>Event First Domain Driven Design</a></li></ul></li><li><a href=#other>Other</a><ul><li><a href=#there-is-a-thing-called-reactive-manifesto><span class="org-todo todo TODO">TODO</span> There is a thing called Reactive Manifesto</a></li></ul></li></ul></nav></aside></header><article class=markdown><div class=backlinks><div></div><p>Referred in</p><ul><li><a href=/knowledge-base/system-design/domain_driven_design/>Domain Driven Design</a></li></ul></div><h2 id=reactive-programming-vs-reactive-systems>Reactive Programming vs Reactive Systems</h2><p>They are not the same.</p><p>Reactive systems apply the reactive principles on a architectural level.</p><p>Reactive Programming can be (and often is) used to build reactive systems but that does not mean that it is a reactive system.</p><p>In order to have a reactive architecture, it means that the reactive systems needs to be separated thorugh asyncronous boundaries.</p><h2 id=https-www-dot-lightbend-dot-com-white-papers-and-reports-reactive-programming-versus-reactive-systems><span class="org-todo todo TODO">TODO</span> <a href=https://www.lightbend.com/white-papers-and-reports/reactive-programming-versus-reactive-systems>https://www.lightbend.com/white-papers-and-reports/reactive-programming-versus-reactive-systems</a></h2><h2 id=domain-driven-design>Domain Driven Design</h2><p>Goal: Software implementation that is based on an evolving model that is understood by the domain experts.</p><p>Domain: Sphere knowledge. Referes to busuiness or idea we are trying to model.</p><p>THe software is the implementation of such domain that experts are able to understand.</p><p>Goal: Build a model that domain expderts understand. One that we show them without they understanding the Software.</p><p>LEads to a way to communicate with them.</p><p>It is important to mention that the model is not hte software. Model represents the understanding of hte domain. The softewrae is solely the implementation of hte model. It can be implemented on diagrams which is not software but an implementation nonetheless.</p><p>But the software should be implemented in a way that reflecfts the model in a way that 1:1 parity between the model and the implementation.</p><p>This requires a common language that both parties. understand leading to:</p><ul><li>Ubiquitous Language: Common language that enables communication between the domain experts and the developers. Terminologuy in there comes from the domain experts. Software termms should be avoided. However sometimes we have to introduce soem terms to the language and such terms should go through the domain experts as well as they may have already a work for that.</li></ul><h3 id=decomposing>Decomposing</h3><p>Business domains are typically large and complicated. With many ideas, actions and rules taht interact in complex ways.</p><p>Strategy: Take the large domain and seperate onto sub domains by grouping related ideas, actions and rules - Maybe use-cases?</p><p>However it is normal having conceps that span multiple sub domains however it is important to avoid abstract already as there may be slight changes. For example, a customer in the context of an online order is different from a customer in the context of in-store purchase. Therefore, there should be modeled as different entities.</p><p>Bounded Context: Ubiquotious Language and model for a sub-domain. The meaning of a concept by change from one bounded context to another.</p><p>Microservices are built around bounded contexts.</p><p>How to determine those boundaries? Some guidelines:</p><ul><li>IMO Use-cases&mldr;</li><li>Consider human culture and interactions, i.e., how different groups of people interact with a given entity.</li><li>Look for changes in the ubiquitous language. Variations suggest a new context.</li><li>Look for variations where the informatio become relevant/irrelevant.</li></ul><p>Strongly separated bounded contexts reuslt in smooth workflows.</p><p>If it awkwards it may be due to a misunderstanding of the domain.</p><h3 id=event-first-domain-driven-design>Event First Domain Driven Design</h3><p>Look at the activities (i.e. use-cases?) and start grouping such activities.</p><h2 id=other>Other</h2><h3 id=there-is-a-thing-called-reactive-manifesto><span class="org-todo todo TODO">TODO</span> There is a thing called Reactive Manifesto</h3><p><a href=https://github.com/reactivemanifesto/reactivemanifesto>https://github.com/reactivemanifesto/reactivemanifesto</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div><a class="flex align-center" href=https://github.com/bphenriques/knowledge-base/edit/master/org/uncategorized/lightbend-academy.org target=_blank rel=noopener><img src=/knowledge-base/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#reactive-programming-vs-reactive-systems>Reactive Programming vs Reactive Systems</a></li><li><a href=#https-www-dot-lightbend-dot-com-white-papers-and-reports-reactive-programming-versus-reactive-systems><span class="org-todo todo TODO">TODO</span> <a href=https://www.lightbend.com/white-papers-and-reports/reactive-programming-versus-reactive-systems>https://www.lightbend.com/white-papers-and-reports/reactive-programming-versus-reactive-systems</a></a></li><li><a href=#domain-driven-design>Domain Driven Design</a><ul><li><a href=#decomposing>Decomposing</a></li><li><a href=#event-first-domain-driven-design>Event First Domain Driven Design</a></li></ul></li><li><a href=#other>Other</a><ul><li><a href=#there-is-a-thing-called-reactive-manifesto><span class="org-todo todo TODO">TODO</span> There is a thing called Reactive Manifesto</a></li></ul></li></ul></nav></aside></main></body></html>