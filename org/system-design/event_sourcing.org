#+TITLE: Event Sourcing
#+SETUPFILE: ./_index.org
#+ROAM_TAGS: system-design
#+ROAM_ALIAS:


* Event Sourcing (ES)

In addition to persisting state, one persists audit logs. This captures the history. It is better to have this in a database as it provides transactionality.

Wary when persisting in the database and in-memory:
- Two potential source of truth if they disagree.
- Both must be updated in transactionality.
- A bug in the code may lead to both of them becoming out-of-sync.

Q: What happens if the audit logs gets out-of-sync with the state?
A: The audit logs is the source of truth as, as opposition, is not possible to rebuild the audit logs from the current state.

This leads to not requiding storing the current state. Event Sourcing captures the intent.

Whenever we need to obtain the current state we replay the logs until we reach the current state. Attention: We mustn't also replay the side-effects.

Append-only is also more efficient in the databases - No deletions or updates.

Event Integrity: The logs are the most important thing and should never be rewritten -> immutable events.

** Optimization through snapshots

What happens if the list of events is too large?
Solution: Ocasionally persist a snapshot and we replay the events from that point on (issue: We may receive an event out-of-order, invalidating the snapshot).

** Versioning

Issue when we have to change the event's schema. This leads to ~ModelV1~, ~ModelV2~, etc. This requires _supporting_ all versions. And requires flexibile formats: JSON, ProtoBuf or AkkA Event Adapters in the lightbend ecosystem that is between the system and the DB translating the ~V1~, ~V2~, ~VN~ to the corresponding and unique Domain entity.
