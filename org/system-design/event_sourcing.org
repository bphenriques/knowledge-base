#+TITLE: Event Sourcing
#+SETUPFILE: ./_index.org
#+ROAM_TAGS: system-design
#+ROAM_ALIAS:


* Event Sourcing (ES)

In addition to persisting state, one persists audit logs. This captures the history. It is better to have this in a database as it provides transactionality.

Wary when persisting in the database and in-memory:
- Two potential source of truth if they disagree.
- Both must be updated in transactionality.
- A bug in the code may lead to both of them becoming out-of-sync.

Q: What happens if the audit logs gets out-of-sync with the state?
A: The audit logs is the source of truth as, as opposition, is not possible to rebuild the audit logs from the current state.

This leads to not requiding storing the current state. Event Sourcing captures the intent.

Whenever we need to obtain the current state we replay the logs until we reach the current state. Attention: We mustn't also replay the side-effects.

Append-only is also more efficient in the databases - No deletions or updates.

Event Integrity: The logs are the most important thing and should never be rewritten -> immutable events.

** Optimization through snapshots

What happens if the list of events is too large?
Solution: Ocasionally persist a snapshot and we replay the events from that point on (issue: We may receive an event out-of-order, invalidating the snapshot).

** Versioning

Issue when we have to change the event's schema. This leads to ~ModelV1~, ~ModelV2~, etc. This requires _supporting_ all versions. And requires flexibile formats: JSON, ProtoBuf or AkkA Event Adapters in the lightbend ecosystem that is between the system and the DB translating the ~V1~, ~V2~, ~VN~ to the corresponding and unique Domain entity.

** Problems

When we need to perform queries that involve several aggregate roots. Because entities need to be rebuilt from events everytime they are visited.

#+begin_quote
The model used to persist are not compatible with the model required during queries.
#+end_quote

See [[file:../system-design/command_query_responsibility_segregation.org][Command Query Responsibility Segregation]].

* Command Sourcing

Similar to command sourcing but persists commands as opposed to events so:
1. Issue command
2. Persist command
3. Run asyncronous the command

- They should be idempotent as they run multiple times (e.g., failures).
- Must be validated so that they do not become stuck in the queue forever.
- Bad: The sender might not be notified if the command fails due to the decouple nature.
