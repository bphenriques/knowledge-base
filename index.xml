<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Bruno Henriques</title><link>https://bphenriques.github.io/knowledge-base/</link><description>Recent content in Introduction on Bruno Henriques</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://bphenriques.github.io/knowledge-base/index.xml" rel="self" type="application/rss+xml"/><item><title>Actor Model</title><link>https://bphenriques.github.io/knowledge-base/concurrency/actor-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/concurrency/actor-model/</guid><description>Concept from 1973 by Carl Hewitt:
Actor is the fundamental unit of computation embodying processing, storage, and communication.
Fundamentals # All computation occurs inside of the actor. Each actor has an address. Actors may create new actors, send messages to them and changing their own behavior to handle new messages (e.g., change the state). An actor does not exist isolated, it works in tandem with others and are arranged in hierarquy:</description></item><item><title>Akka Cluster</title><link>https://bphenriques.github.io/knowledge-base/akka/akka_cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/akka/akka_cluster/</guid><description>Akka Cluster # Scenario: Make actors communicate across the network.
Allows actors to communicate across the network, greatly simplifying the process. Each node represents an actor system and they all share the same name.
Akka Cluster Aware Routers # Scenario: High workload.
Scalling vertically has limits. Introducing Akka Cluster Aware Routers, that allows scalling the system horizontally. I.e., large tasks are broken on smaller tasks that are routed to an especific node of our cluster.</description></item><item><title>Akka Dispatcher</title><link>https://bphenriques.github.io/knowledge-base/akka/akka_dispatcher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/akka/akka_dispatcher/</guid><description>The engine of Akka as it decides when a actor should process messsages and when it must yield the thread for others. It means that dispatchers are in control of the thread time and of the threads themselves.
Dispatcher (default): Event-driven dispatcher, sharing threads from thread pool. PinnedDispatcher: Dedicated thread per actor. CallingThreadDispatcher: Just for testing. The best tips are:
Adjust throughput to deliver more messages to the actors before yielding.</description></item><item><title>Akka Router</title><link>https://bphenriques.github.io/knowledge-base/akka/akka_router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/akka/akka_router/</guid><description>Intro # Context: Paralellize work by creating additional actors in order to solve bottlenecks.
Router routes messages to destination actors called routees that can process messages in paralell to improve throughput. The way routing is done may be configured to fit the use-case.
Routing Strategies # Determines how router routes to its routees.
RandomRoutingLogic: Pure random and fast. May be unbalanced. RoundRobinRoutingLogic: Take turns. Is more fair and distributed.</description></item><item><title>Akka Sharding</title><link>https://bphenriques.github.io/knowledge-base/akka/akka_sharding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/akka/akka_sharding/</guid><description>Akka Cluster Sharding # Distribute actors across a cluster:
Entities: The main unit (e.g., UserId) Shards: Holds entities (e.g., each shard holds 10 UserIds). Shard Region: Holds Shards. Shard Coordinator: Manages shards. Entity # The main unit is: Entity identified by the EntityId which in essence represents the aggregate root&amp;rsquo;s identifier of a concept of our domain (e.g., UserId) and is unique within the cluster. This leads to Strong Consistency given that Akka provides the single thread illusion.</description></item><item><title>Akka Streams</title><link>https://bphenriques.github.io/knowledge-base/akka/akka_streams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/akka/akka_streams/</guid><description>Akka Streams # Use cases: live-data, ETL systems, streaming.
It is more efficient to consume asyncronously. Avoid flooding a slow consumer (backpressure). Initiative to provide a standard for async stream processing with non-blocking backpressure.
Components of a Reactive Stream:
Publisher: Publishes data to stream Subscriber: Consumes data from the stream. Processor: Acts as both a publisher and a subscriber, obeying the contract for each. Subscription: Connects a subscriber to a publisher to initiate a message flow.</description></item><item><title>Akka Testing</title><link>https://bphenriques.github.io/knowledge-base/akka/akka_testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/akka/akka_testing/</guid><description>Test Actor Ref # Syncronous and ideal for white-box testing as we can change the internal state.
Test Probes # Black-box testing and then verify if expecific messages were sent (and other assertions).
(black box is always better :) )</description></item><item><title>Amdah's Law</title><link>https://bphenriques.github.io/knowledge-base/concurrency/amdah_s_law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/concurrency/amdah_s_law/</guid><description>In short, contention limits paralelization.
Defines the maximum improvement gaines by parallel procesing. Improvements from paralelization are limited to the code that can be paralelized. Contention limits such paralism reducing the advantages of the improvements. Does not matter as long as the contention exist.</description></item><item><title>Bug Management</title><link>https://bphenriques.github.io/knowledge-base/monitoring/bug-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/monitoring/bug-management/</guid><description>Some personal notes on simplifying the process so that one can focus on getting back to the other tasks at hand.
On Reporting Bugs # Focus on the impact for the client. You do not need to debug right away. You do not need to establish the timeline - The report can solely include the context. The person assigned to the issue will pick on the context provided in the ticket and explore.</description></item><item><title>Command Query Responsibility Segregation (CQRS)</title><link>https://bphenriques.github.io/knowledge-base/system-design/command_query_responsibility_segregation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/command_query_responsibility_segregation/</guid><description>Use Cases # Auditing (e.g., banking, accounting) High Scalability High Resiliency Some Aggregate Roots are a better fit for write models but do not fit other read models. Requirements for both models are different.
What # Command Query Responsibility Segregation (CQRS) aims to separate read models from write models. This is specially problematic when using Event Sourcing. Note that Event Sourcing is not a requirement for CQRS but are often combined.</description></item><item><title>Command Sourcing</title><link>https://bphenriques.github.io/knowledge-base/system-design/command_sourcing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/command_sourcing/</guid><description>Command Sourcing # Similar to Event Sourcing but persists commands as opposed to events so:
Issue command
Persist command
Run asyncronous the command
They should be idempotent as they run multiple times (e.g., failures).
Must be validated so that they do not become stuck in the queue forever.
Bad: The sender might not be notified if the command fails due to the decouple nature.</description></item><item><title>Consistency And Availability</title><link>https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/consistency_and_availability/</guid><description>Scalability # It can meets increases in demand while remaining responsive.
This is different from performance. Performance optimizes response time (latency) while scalability optimizes ability to handle load. Requests per second actually measures both but we do not know which aspect was improved.
Note Scalability is not the number of requests qwe can handle a in a given period of time (req/sec) but he number of requests itself (load).</description></item><item><title>Coursera</title><link>https://bphenriques.github.io/knowledge-base/learning/coursera/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/learning/coursera/</guid><description>Interested in:
https://www.coursera.org/learn/learning-how-to-learn</description></item><item><title>Curriculum</title><link>https://bphenriques.github.io/knowledge-base/work/curriculum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/work/curriculum/</guid><description>Some reference pages:
https://www.myperfectresume.com/cv/examples/computer-software/engineer https://business.linkedin.com/talent-solutions/blog/linkedin-best-practices/2016/7-linkedin-profile-summaries-that-we-love-and-how-to-boost-your-own</description></item><item><title>Databases Overview</title><link>https://bphenriques.github.io/knowledge-base/databases/databases_overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/databases/databases_overview/</guid><description>https://medium.com/@rakyll/things-i-wished-more-developers-knew-about-databases-2d0178464f78</description></item><item><title>Domain Driven Design</title><link>https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/domain_driven_design/</guid><description>Goal # Evolving Shared Model understood by domain experts and by who implements it. Being a model, it means that it can be implemented in different ways, from diagrams to software. Regardless of how it is implemented, it must reflect the model.
Useful for modelling use-cases before attempting to implement it whether in Software or mere Diagrams.
Ubiquitous Languague # Common language that enables communication between the domain experts and the developers.</description></item><item><title>Emacs</title><link>https://bphenriques.github.io/knowledge-base/editors/emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/editors/emacs/</guid><description>Org-Mode # Org-protocol is cool and opens possibilities (like there weren&amp;rsquo;t enoguh :overwhelmed:):
https://orgmode.org/worg/org-contrib/org-protocol.html#orgheadline8 Configuring # Literate config is a thing but unfortunately as far as I researched it has to be contained in a single file. I rather have separate files per use-case.
Cool reference links:
https://tecosaur.github.io/emacs-config/config.html http://doc.norang.ca/org-mode.html:w https://github.com/jethrokuan/dots/blob/0064ea2aab667f115a14ce48292731db46302c53/.doom.d/config.el#L495 https://github.com/nmartin84/.doom.d#orgb81fe7f https://github.com/howardabrams/dot-files/blob/master/emacs-org.org</description></item><item><title>Event Sourcing</title><link>https://bphenriques.github.io/knowledge-base/system-design/event_sourcing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/event_sourcing/</guid><description>Event Sourcing (ES) # In addition to persisting state, one persists audit logs. This captures the history. It is better to have this in a database as it provides transactionality.
Wary when persisting in the database and in-memory:
Two potential source of truth if they disagree. Both must be updated in transactionality. A bug in the code may lead to both of them becoming out-of-sync. Q: What happens if the audit logs gets out-of-sync with the state?</description></item><item><title>Gossip Protocol</title><link>https://bphenriques.github.io/knowledge-base/protocols/gossip_protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/protocols/gossip_protocol/</guid><description>Some of these text may be interwined with specifities of the Gossip Protocol within Akka.
Context: TODO
At a regular interval, each member sends their view of the cluster state to a random node, including:
The status of each member If each member has seen this version of the cluster state. Eventually consistent as after some time (aka convergence), all nodes will share the same state. Each node decides if it has reached convergence.</description></item><item><title>Gunther's Universal Scalability Law</title><link>https://bphenriques.github.io/knowledge-base/concurrency/gunther_s_universal_scalability_law/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/concurrency/gunther_s_universal_scalability_law/</guid><description>Increasing concurrency can cause negative resutrns due to contention and coherency delay.
Picks from Amdah&amp;rsquo;s Law. In addition to contention, it accounts for coeherency delay.
As the system scales up, the cost to coordinate between nodes exceeds any benefits.</description></item><item><title>Hands-on Scala Programming</title><link>https://bphenriques.github.io/knowledge-base/learning/hands_on_scala_programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/learning/hands_on_scala_programming/</guid><description>Follows my notes on the Haoyi Li.&amp;rsquo;s book: &amp;ldquo;Hands-on Scala Programming&amp;rdquo; (https://www.handsonscala.com/).
As an experiment, I coding directly in the org-mode file using Babel to execute the Scala blocks:
TODO Some introduction # Point to dotfiles Point to the Babel package Notes # Lack of auto-complete when writing here. Compilation errors are hard to track. Workaround is to open a separate buffer with the ammonite REPL console.</description></item><item><title>Heartbeat</title><link>https://bphenriques.github.io/knowledge-base/protocols/heartbeat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/protocols/heartbeat/</guid><description>In order to detect failures, systems communicate with one another to verify communication. If the communication is deemed broken, then the system may be considered as Unreachable depending on he heartbeat history and how the Failure Detection is configured. I.e., a single heartbeat does not mean that the member is Unreachable.</description></item><item><title>JWT</title><link>https://bphenriques.github.io/knowledge-base/security/jwt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/security/jwt/</guid><description>What it is # JSON Web Tokens
What it solves # What it does not solve #</description></item><item><title>Message Driven Architecture</title><link>https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/message_driven_architecture/</guid><description>Asyncronous and non-blocking. The sender does not actively wait for a response.
Advantages:
Resources are freed immediatly. Reduced contention Messages can be queued for deleivery in case the receiver&amp;rsquo;s is offline. Provides a higher level of reliability. Disavantages:
Make transactions more difficult. How to manage long running transactions that span multiple microservices. Holding transactions open for long periods result in slow, brittle systems. The role of syncronous messags:</description></item><item><title>Messaging Systems Comparison</title><link>https://bphenriques.github.io/knowledge-base/messaging-systems/messaging-systems-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/messaging-systems/messaging-systems-overview/</guid><description>Kafka # Event Streaming, persistent.
RabbitMQ # Low latency.
Pulsar # Made by Apache
TODO # Read this comparison: https://www.confluent.io/kafka-vs-pulsar/#:~:text=In%20reality%2C%20Kafka%2C%20RabbitMQ%2C,Pulsar%20sits%20somewhere%20in%20between.</description></item><item><title>Microservices</title><link>https://bphenriques.github.io/knowledge-base/system-design/microservices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/microservices/</guid><description>Subset of Service Oriented Architecture (SOA) where each service is deployed separately:
Microservices can be physically separated and independently deployed. Each have its own data store. Independent and self governing. Communication is syncronous or asyncronous (e.g., through messaging systems). Loose coupling between components (more or less by experience but that is design flaw likely :thinking:). Shorter development and release cycles. Each scale independently (either through physical or virtual machines). Advantages # Deployed/Scaled as needed.</description></item><item><title>Monolith</title><link>https://bphenriques.github.io/knowledge-base/system-design/monolith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/monolith/</guid><description>Charateristics # Deployed as a single unit. No Clear Isolation. Complex Depedencies which in turn makes it hard to understand and modify. Big Bang Style Releases Long Cycle Times Careful releases Scalation is done with multiple copies and uses the database as consistency between them. Advantages: # Easy Cross Module Refactor Easier to maitain consistency Single Deploy Process Single thing to monitor Simple Scalability Model Disavantages: # Limited by the maximum size of a single phyisical machine.</description></item><item><title>Random Memories</title><link>https://bphenriques.github.io/knowledge-base/work/random-memories/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/work/random-memories/</guid><description>Curious ideas/sentences and what not from now and then. Some things are pretty obvious but worthwhile remembering (:
Failure in systems are inevitable. We have to accept and build a system that isolates such failures in a way that becomes unnoticible to the end-user. User does not care whether the software was faulty due to a third-party vender or not. When we build software we have to consider third-party vendors and if we don&amp;rsquo;t properly isolate ourselves from their faulty behavior, users are going to pay for that.</description></item><item><title>Reactive Systems</title><link>https://bphenriques.github.io/knowledge-base/system-design/reactive_systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/reactive_systems/</guid><description>Goal # Provide an experience that is responsive under all conditions. Note that reactive programming is not the same as reactive systems.
This requires:
Ability to scale from 10 users to million of users. Consume solely the resources required to support the current work-load. Reactive Principles # Systems that apply the following principles are considered reactive systems (see more here).
Responsive # Always respond in a timely manner.</description></item><item><title>Readme</title><link>https://bphenriques.github.io/knowledge-base/documentation/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/documentation/readme/</guid><description>Several examples # https://github.com/matiassingers/awesome-readme Like minimalistic versions as they require less maintenance (hmmm :thinking-face:)</description></item><item><title>Service Oriented Architecture (SOA)</title><link>https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture_soa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/service_oriented_architecture_soa/</guid><description>TODO very incomplete # As opposed to Monolith, services do not share a database and all access must be done through a API exposed by the service. They may be in the same process (Monolith) or may be separated (Microservices). This reduces coupling.</description></item><item><title>Sharding or Partitioning</title><link>https://bphenriques.github.io/knowledge-base/databases/databases_sharding-or-partitioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/databases/databases_sharding-or-partitioning/</guid><description>Technique used by some data stores to reduce contention without sacrificing consistency.
Records are distributed across nodes using a Shard Key or a Partition Key that will be used by the Database Router that redirects requests to the correct shard/partition.
Benefits:
Contention is isolated to a shard/partition. Given that each shard stores a part of the dataset, it is only handling a small part of the overall load. Improves elasticity.</description></item><item><title>SLI/SLO</title><link>https://bphenriques.github.io/knowledge-base/system-design/system-design_sli-slo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/system-design_sli-slo/</guid><description>Service Level Indicator (SLI): Performance indicator measured as a ratio of two numbers. Service Level Objective (SLO): Defines a target SLI as measurment of the systems&amp;rsquo;s reliability. Service Level Agreement (SLA): Business contract regarding the expected SLO. It is far productive measuring them as use-histories as it defines the critical paths.</description></item><item><title>Stateless</title><link>https://bphenriques.github.io/knowledge-base/system-design/system-design_stateless/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/system-design/system-design_stateless/</guid><description>Requests are self-contained and have all the information required to be completed. Requests can be processed on any instance of the application. Some &amp;ldquo;Stateless&amp;rdquo; systems are not trully stateless as the state is contained in a database:
Required to have strong consistency (the single source of truth). However this means that the database may become the bottleneck. The database also represents the single point of failure which may lead to an unresponsive systems.</description></item><item><title>States of Data</title><link>https://bphenriques.github.io/knowledge-base/data-processing/states-of-data/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/data-processing/states-of-data/</guid><description>States of data:
At Rest: Data that is not consumed at the time is injested. It is stored and then consumed later in a batch process. In Transit: Data that is travelling between point A and point B. In Use: Data that is opened for treatment Encountered several concerns regarding how such data must be handled. Follows a link to be reviewed later:three-states-of-data</description></item><item><title>Technical Writing</title><link>https://bphenriques.github.io/knowledge-base/learning/technical_writing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/learning/technical_writing/</guid><description>https://developers.google.com/tech-writing/overview</description></item><item><title>Thinking Tools</title><link>https://bphenriques.github.io/knowledge-base/work/thinking_tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/work/thinking_tools/</guid><description>Follows some interesting resources:
https://untools.co/</description></item><item><title>Way of work</title><link>https://bphenriques.github.io/knowledge-base/work/way-of-work/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/work/way-of-work/</guid><description>It&amp;rsquo;s not about being right nor prove others wrong # Corollary 1: if it&amp;rsquo;s wrong but it works, then it&amp;rsquo;s not wrong. Corollary 2: if you&amp;rsquo;re right but it doesn&amp;rsquo;t change the outcome, then it doesn&amp;rsquo;t matter. Corollary 3: if you&amp;rsquo;re right, but it doesn&amp;rsquo;t work, then you&amp;rsquo;re wrong. Corollary 4: if you prove someone else wrong, but their answer works and yours doesn&amp;rsquo;t, then they&amp;rsquo;re right and you&amp;rsquo;re wrong.</description></item><item><title>Emacs</title><link>https://bphenriques.github.io/knowledge-base/snippets/emacs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/snippets/emacs/</guid><description>TODO Personalize deft for other directories # For now I do not need.
;;function to run deft in specified directory (defun bjm-deft (dir) &amp;#34;Run deft in directory DIR&amp;#34; (setq deft-directory dir) (switch-to-buffer &amp;#34;*Deft*&amp;#34;) (kill-this-buffer) (deft) )</description></item><item><title>Jackson</title><link>https://bphenriques.github.io/knowledge-base/snippets/jackson/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/snippets/jackson/</guid><description>Sane Settings # After working a while with this I want to register these sane defaults:
configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true) configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false) FAIL_ON_NULL_FOR_PRIMITIVES # Setting FAIL_ON_NULL_FOR_PRIMITIVES forces clients to explicitely provide all values including primitives. Consider the following POJO:
data class Foo(bar: Boolean) Without the setting, a payload such as { } would render ~Foo(bar=false)~ despite the lack of default value. Given this, to guarantee consistency between the source-code and the external contract, I advise enabling this.</description></item><item><title>Akka</title><link>https://bphenriques.github.io/knowledge-base/uncategorized/akka/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/uncategorized/akka/</guid><description>Akka # Toolkit and runtime for building highly concurrent, distributed and fault tolerant message-driven application in the JVM. It can be used to build Reactive Systems.
Proposes unified programming model for:
Simpler concurrency: single threaded ilusion as each actor processes a messsage at a time (no need to locks or syncronization strategues). Simpler distribution: is distributed by default (see more on Akka Cluster). Simpler fault tolerancy: Decouples communication from failure handling.</description></item><item><title>dotfiles</title><link>https://bphenriques.github.io/knowledge-base/uncategorized/dotfiles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/uncategorized/dotfiles/</guid><description>Want to migrate to Nix.
Emacs Configuration # See more on Emacs (some reason it gives ambiguous reference).</description></item><item><title>gpg</title><link>https://bphenriques.github.io/knowledge-base/uncategorized/gpg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/uncategorized/gpg/</guid><description>Automatically export public key to a server:
$ gpg --keyserver pgp.mit.edu --send-keys &amp;lt;KEY&amp;gt;</description></item><item><title>Nix</title><link>https://bphenriques.github.io/knowledge-base/uncategorized/nix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/uncategorized/nix/</guid><description> Reproducible Each reproduction (a build) produces a generation Links:
https://wiki.nikitavoloboev.xyz/package-managers/nix https://nixcloud.io/tour/?id=1 https://stephank.nl/p/2020-06-01-a-nix-primer-by-a-newcomer.html https://engineering.shopify.com/blogs/engineering/what-is-nix https://www.nmattia.com/posts/2018-03-21-nix-reproducible-setup-linux-macos.html https://shopify.engineering/what-is-nix</description></item><item><title>Relevant xkcds</title><link>https://bphenriques.github.io/knowledge-base/uncategorized/relevant-xkcds/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/uncategorized/relevant-xkcds/</guid><description>On Standards # https://xkcd.com/927/</description></item><item><title>Stack Web Notes</title><link>https://bphenriques.github.io/knowledge-base/uncategorized/web-stack-enties/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bphenriques.github.io/knowledge-base/uncategorized/web-stack-enties/</guid><description>How To Drive Change as a Software Engineer # Source: https://www.lihaoyi.com/post/HowToDriveChangeasaSoftwareEngineer.html
The Dark Side of Events - YouTube # Source: https://www.youtube.com/watch?v=URYPpY3SgS8&amp;amp;feature=youtu.be&amp;amp;t=1884
Ask HN: How to Take Good Notes? | Hacker News # Source: https://news.ycombinator.com/item?id=22473209
Unlearning toxic behaviors in a code review culture | by Sandya Sankarram | Medium # Source: https://medium.com/@sandya.sankarram/unlearning-toxic-behaviors-in-a-code-review-culture-b7c295452a3c
Org Mode - Organize Your Life In Plain Text! # Source: http://doc.norang.ca/org-mode.html#GettingOrgModeWithGit
ðŸ§  Own Your Second Brain: Set Up org-roam on Your Own Machine # Source: https://www.</description></item></channel></rss>